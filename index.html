<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>眼动追踪数据收集系统 - 视频观看版</title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
    
    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyB6O5l6uZa-6sywCZTGRJx2CKPuq3KeBF0",
            authDomain: "index-9f58d.firebaseapp.com",
            projectId: "index-9f58d",
            storageBucket: "index-9f58d.appspot.com",
            messagingSenderId: "718279245978",
            appId: "1:718279245978:web:93a9a07473ad8d3e6a5f23"
        };
        
        // 初始化 Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        
        // 生成唯一用户ID
        const generateUniqueUserId = () => {
            const timestamp = Date.now();
            const randomStr = Math.random().toString(36).substr(2, 9);
            return `user_${timestamp}_${randomStr}`;
        };
        
        const sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        const userId = generateUniqueUserId(); // 每个用户都有唯一ID
        console.log('会话ID:', sessionId);
        console.log('用户ID:', userId);

        // 动态加载WebGazer
        async function loadWebGazerScript() {
            const sources = [
                'https://webgazer.cs.brown.edu/webgazer.js',
                'https://unpkg.com/webgazer@2.0.2/dist/webgazer.js',
                'https://cdn.jsdelivr.net/npm/webgazer@2.0.2/dist/webgazer.min.js'
            ];
            for (const source of sources) {
                try {
                    await new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = source;
                        script.onload = resolve;
                        script.onerror = () => reject(new Error(`无法从 ${source} 加载WebGazer`));
                        script.timeout = 10000;
                        document.head.appendChild(script);
                    });
                    console.log(`WebGazer从 ${source} 加载成功`);
                    return true;
                } catch (error) {
                    console.error(`加载失败: ${error.message}`);
                }
            }
            return false;
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/heatmap.js/2.0.0/heatmap.min.js"></script>
    <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body { margin: 0; padding: 0; font-family: Arial, sans-serif; background: #f0f0f0; }
        #heatmapContainer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1000; visibility: hidden; }
        #plotting_canvas { position: fixed; top: 0; left: 0; cursor: crosshair; z-index: 900; pointer-events: none; }
        #content { position: relative; z-index: 1; padding: 30px; max-width: 800px; margin: 10px auto; background: white; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        #statsPanel { 
            position: fixed; 
            top: 20px; 
            right: 20px; 
            background: rgba(0,0,0,0.85); 
            color: white; 
            padding: 10px 15px; 
            border-radius: 10px; 
            z-index: 2000; 
            width: 200px; 
            font-size: 11px;
        }
        .stat-item { 
            margin: 8px 0; 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
        }
        .stat-value { 
            font-weight: bold; 
            color: #4CAF50; 
            font-size: 10px;
        }
        #debugPanel { position: fixed; bottom: 20px; right: 20px; background: rgba(0,0,0,0.9); color: #00ff00; padding: 15px; border-radius: 8px; z-index: 2000; max-width: 350px; font-family: monospace; font-size: 12px; max-height: 300px; overflow-y: auto; display: none; }
        .controls { text-align: center; margin: 20px 0; }
        .btn { background: #4CAF50; color: white; padding: 12px 24px; border: none; border-radius: 5px; cursor: pointer; margin: 0 10px; font-size: 16px; transition: background 0.3s; }
        .btn:hover { background: #45a049; }
        .btn.danger { background: #f44336; }
        .btn.danger:hover { background: #da190b; }
        .btn:disabled { background: #ccc; cursor: not-allowed; }
        .btn.test { background: #2196F3; }
        .btn.test:hover { background: #1976D2; }
        .btn.toggle { background: #FF9800; }
        .btn.toggle:hover { background: #F57C00; }
        .status { position: fixed; top: 20px; left: 20px; padding: 10px 15px; border-radius: 20px; font-weight: bold; z-index: 2000; }
        .status.ready { background: #4CAF50; color: white; }
        .status.calibrating { background: #ff9800; color: white; }
        .status.error { background: #f44336; color: white; }
        .status.initializing { background: #2196F3; color: white; }
        .status.loading { background: #9C27B0; color: white; }
        
        #webgazerVideoContainer {
            display: block !important; 
            position: fixed !important;
            top: 0px !important;
            left: 0px !important;
            width: 320px !important;
            height: 240px !important;
            z-index: 1;
        }
        
        .Calibration {
            width: 20px;
            height: 20px;
            border-radius: 25px;
            background-color: red;
            opacity: 0.2;
            border: 1px solid black;
            position:fixed;
            z-index: 100000;
        }
        #Pt1{ top: 70px; left:340px; }
        #Pt2{ top: 70px; left:50vw; margin-left: 340; }
        #Pt3{ top: 70px; right:2vw; }
        #Pt4{ top:50vh; left:2vw; }
        #Pt5{ top: 50vh; left: 50vw; }
        #Pt6{ top: 50vh; right:2vw; }
        #Pt7{ bottom:2vw; left: 2vw; }
        #Pt8{ bottom:2vw; left:50vw; }
        #Pt9{ bottom:2vw; right:2vw; }

        #Accuracy { background-color: #222; color: white; padding: 8px; border-radius: 5px; text-align: center; font-size: 11px; margin: 8px 0; }
        .collection-status { margin-top: 10px; padding: 8px; border-radius: 5px; text-align: center; font-size: 10px; }
        .collection-status.connected { background: #4CAF50; color: white; }
        .collection-status.disconnected { background: #f44336; color: white; }
        .collection-status.uploading { background: #ff9800; color: white; }
        .firebase-status { margin-top: 8px; padding: 8px; border-radius: 4px; text-align: center; font-size: 10px; }
        .heatmap-visible { visibility: visible !important; }
        
        /* 视频时间戳覆盖层 - 仅在热力图截图时可见 */
        #videoInfoOverlay {
            position: fixed; /* 改为 fixed 以确保在全屏时可见 */
            top: 10px;
            left: 10px;
            background: rgba(255, 0, 0, 0.9); /* 改为红色背景便于调试 */
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            z-index: 10000; /* 提高 z-index 确保在全屏时可见 */
            pointer-events: none;
            visibility: hidden; /* 默认隐藏，用户看不到 */
            border: 2px solid white; /* 添加白色边框便于识别 */
        }
        
        /* 全屏时的视频容器 */
        .video-container {
            position: relative;
            display: inline-block;
            width: 100%;
        }
    </style>
</head>
<body>
    <div id="status" class="status loading">正在加载库文件...</div>
    <canvas id="plotting_canvas" width="500" height="500"></canvas>

    <div id="statsPanel">
        <h4 style="margin: 0 0 8px 0; text-align: center; color: #4CAF50; font-size: 13px;">📊 眼动数据统计</h4>
        <div class="stat-item"><span>用户ID:</span><span id="userIdDisplay" class="stat-value" style="font-size: 9px; word-break: break-all;"></span></div>
        <div class="stat-item"><span>会话ID:</span><span id="sessionIdDisplay" class="stat-value" style="font-size: 9px; word-break: break-all;"></span></div>
        <div class="stat-item"><span>注视点总数:</span><span id="totalGazes" class="stat-value">0</span></div>
        <div class="stat-item"><span>眼跳次数:</span><span id="saccadeCount" class="stat-value">0</span></div>
        <div class="stat-item"><span>注视次数:</span><span id="fixationCount" class="stat-value">0</span></div>
        <div class="stat-item"><span>平均注视时间:</span><span id="avgFixationTime" class="stat-value">0ms</span></div>
        <div class="stat-item"><span>热力图快照:</span><span id="heatmapSnapshots" class="stat-value">0</span></div>
        <div class="stat-item"><span>数据快照数:</span><span id="snapshotCount" class="stat-value">0</span></div>
        <div class="stat-item"><span>运行时间:</span><span id="runningTime" class="stat-value">0s</span></div>
        <div id="Accuracy">等待校准...</div>
        <div class="stat-item"><span>系统状态:</span><span id="systemStatus" class="stat-value">加载中</span></div>
        <div class="collection-status disconnected" id="collectionStatus">📈 数据收集: 未开始</div>
        <div class="firebase-status disconnected" id="firebaseStatus">🔥 Firebase: 未连接</div>
        <button class="btn test" onclick="testFirebaseConnection()" style="width: 100%; margin-top: 4px; padding: 4px; font-size: 10px;">🧪 测试连接</button>
        <button class="btn test" onclick="forceSaveData()" style="width: 100%; margin-top: 4px; padding: 4px; font-size: 10px;">💾 强制保存</button>
        <button class="btn toggle" onclick="toggleHeatmap()" style="width: 100%; margin-top: 4px; padding: 4px; font-size: 10px;">🔥 显示/隐藏热力图</button>
        <button class="btn test" onclick="testVideoCapture()" style="width: 100%; margin-top: 4px; padding: 4px; font-size: 10px;">📹 测试视频截图</button>
        <button class="btn test" onclick="toggleDebug()" style="width: 100%; margin-top: 4px; padding: 4px; font-size: 10px;">🐛 显示调试</button>
        <button class="btn test" onclick="testOverlayVisibility()" style="width: 100%; margin-top: 4px; padding: 4px; font-size: 10px;">👁️ 测试覆盖层</button>
        <button class="btn test" onclick="testDataCollection()" style="width: 100%; margin-top: 4px; padding: 4px; font-size: 10px;">📊 测试数据收集</button>
        <button class="btn test" onclick="testFullscreenCapture()" style="width: 100%; margin-top: 4px; padding: 4px; font-size: 10px;">🎬 测试全屏截图</button>
        <button class="btn test" onclick="testGazeMapping()" style="width: 100%; margin-top: 4px; padding: 4px; font-size: 10px;">🎯 测试注视映射</button>
        <button class="btn test" onclick="testCoordinateTransform()" style="width: 100%; margin-top: 4px; padding: 4px; font-size: 10px;">🔧 测试坐标转换</button>
        <button class="btn test" onclick="forceRecalibrate()" style="width: 100%; margin-top: 4px; padding: 4px; font-size: 10px;">⚡ 强制重校准</button>
    </div>

    <div id="debugPanel"><div id="debugInfo">调试信息将在这里显示...</div></div>
    <div id="heatmapContainer"></div>
    
    <div class="calibrationDiv">
        <input type="button" class="Calibration" id="Pt1">
        <input type="button" class="Calibration" id="Pt2">
        <input type="button" class="Calibration" id="Pt3">
        <input type="button" class="Calibration" id="Pt4">
        <input type="button" class="Calibration" id="Pt5">
        <input type="button" class="Calibration" id="Pt6">
        <input type="button" class="Calibration" id="Pt7">
        <input type="button" class="Calibration" id="Pt8">
        <input type="button" class="Calibration" id="Pt9">
    </div>

    <div id="content">
        <div class="controls">
            <button class="btn" id="startBtn" onclick="startEyeTracking()" disabled>🚀 启动眼动追踪</button>
            <button class="btn" id="calibrateBtn" onclick="PopUpInstruction()" disabled>🎯 开始校准</button>
            <button class="btn" onclick="Restart()">🔄 重新校准</button>
            <button class="btn" onclick="exportData()">📊 导出数据</button>
        </div>

        <div style="text-align: center; margin: 20px 0; padding: 15px; background: #f2f2f2; border-radius: 8px;">
            <div class="video-container">
                <video 
                    id="eyeTrackingVideoPlayer" 
                    src="https://res.cloudinary.com/ddp3tohxk/video/upload/v1757416692/%E9%99%A4%E8%9E%A8%E4%BB%AA_bzhlgy.mp4" 
                    width="100%" 
                    crossorigin="anonymous"
                    preload="auto"
                    style="border-radius: 8px; background: #000; max-height: 400px;"
                ></video>
                <div id="videoInfoOverlay">
                    用户: <span id="overlayUserId"></span> | 时间: <span id="overlayTimestamp">0.00s</span>
                </div>
            </div>
            <div style="margin-top: 10px;">
                <button class="btn" id="playVideoBtn" onclick="startVideoExperiment()" style="font-size: 18px; padding: 15px 30px;">▶️ 开始视频实验</button>
            </div>
        </div>

    </div>

    <script>
        // ===========================================
        // 全局变量定义
        // ===========================================
        let heatmapInstance = null, gazeCount = 0, snapshotCount = 0, heatmapSnapshotCount = 0, saccadeCount = 0, fixationCount = 0, totalFixationTime = 0;
        let startTime = Date.now();
        let isTracking = false, webgazerReady = false, debugMode = false, librariesLoaded = false, firebaseConnected = false;
        let isCalibrating = false, isVideoExperimentActive = false;
        
        var PointCalibrate = 0;
        var CalibrationPoints = {};
        
        let eyeTrackingData = { gazePoints: [], saccades: [], fixations: [], heatmapSnapshots: [], calibrationData: { points: [], accuracyPercentage: null, timestamp: null } };

        let lastGazePoint = null, currentFixation = null;
        const fixationThreshold = 50, fixationTimeThreshold = 100;

        let autoSaveInterval = null, heatmapSnapshotInterval = null, statsUpdateInterval = null;

        // 新增：核心管理器实例
        let coordinateTransformer = null;
        let heatmapManager = null;
        let fullscreenManager = null;
        let calibrationManager = null;
        let videoDisplayArea = { x: 0, y: 0, width: 0, height: 0 };

        document.getElementById('sessionIdDisplay').textContent = sessionId;
        document.getElementById('userIdDisplay').textContent = userId;
        document.getElementById('overlayUserId').textContent = userId;

        // ===========================================
        // 坐标转换管理器（修复版本）
        // ===========================================
        class CoordinateTransformer {
            constructor() {
                this.isFullscreen = false;
                this.calibrationOffset = { x: 0, y: 0 };
                this.scaleFactor = { x: 1, y: 1 };
                this.transformationMatrix = null;
                this.lastKnownScreenSize = { width: window.innerWidth, height: window.innerHeight };
                this.fullscreenOffset = { x: 0, y: 0 }; // 全屏模式下的额外偏移
            }
            
            // 重新校准坐标系统
            recalibrate() {
                debug('开始重新校准坐标转换系统...');
                
                const currentScreenSize = { width: window.innerWidth, height: window.innerHeight };
                const sizeChanged = currentScreenSize.width !== this.lastKnownScreenSize.width || 
                                  currentScreenSize.height !== this.lastKnownScreenSize.height;
                
                if (sizeChanged) {
                    debug(`屏幕尺寸变化: ${this.lastKnownScreenSize.width}x${this.lastKnownScreenSize.height} -> ${currentScreenSize.width}x${currentScreenSize.height}`);
                    
                    // 计算缩放因子
                    this.scaleFactor.x = currentScreenSize.width / this.lastKnownScreenSize.width;
                    this.scaleFactor.y = currentScreenSize.height / this.lastKnownScreenSize.height;
                    
                    this.lastKnownScreenSize = currentScreenSize;
                    debug(`计算缩放因子: x=${this.scaleFactor.x.toFixed(3)}, y=${this.scaleFactor.y.toFixed(3)}`);
                }
                
                this.isFullscreen = document.fullscreenElement !== null;
                debug(`全屏状态: ${this.isFullscreen}`);
            }
            
            // WebGazer原始坐标 -> 标准化屏幕坐标
            transform(rawX, rawY) {
                // 验证输入数据
                if (!this.isValidCoordinate(rawX, rawY)) {
                    return null;
                }
                
                let transformedX = rawX;
                let transformedY = rawY;
                
                // WebGazer在全屏模式下可能返回基于文档的坐标，需要转换为视口坐标
                if (this.isFullscreen) {
                    // 全屏模式：WebGazer可能返回相对于文档的坐标，需要减去滚动偏移
                    transformedX = rawX - window.scrollX;
                    transformedY = rawY - window.scrollY;
                    
                    // 应用全屏偏移修正
                    transformedX += this.fullscreenOffset.x;
                    transformedY += this.fullscreenOffset.y;
                    
                    debug(`全屏坐标转换: 原始(${rawX}, ${rawY}) -> 转换后(${transformedX}, ${transformedY})`);
                } else {
                    // 窗口模式：应用校准偏移
                    transformedX += this.calibrationOffset.x;
                    transformedY += this.calibrationOffset.y;
                }
                
                // 应用缩放因子（如果需要）
                if (this.scaleFactor.x !== 1 || this.scaleFactor.y !== 1) {
                    transformedX *= this.scaleFactor.x;
                    transformedY *= this.scaleFactor.y;
                }
                
                // 边界检查和修正
                transformedX = Math.max(-50, Math.min(window.innerWidth + 50, transformedX));
                transformedY = Math.max(-50, Math.min(window.innerHeight + 50, transformedY));
                
                return {
                    x: Math.floor(transformedX),
                    y: Math.floor(transformedY),
                    original: { x: rawX, y: rawY },
                    applied: {
                        offset: this.isFullscreen ? this.fullscreenOffset : this.calibrationOffset,
                        scale: this.scaleFactor,
                        mode: this.isFullscreen ? 'fullscreen' : 'windowed'
                    }
                };
            }
            
            // 验证坐标有效性
            isValidCoordinate(x, y) {
                return typeof x === 'number' && typeof y === 'number' && 
                       !isNaN(x) && !isNaN(y) && 
                       x >= -500 && y >= -500 && // 扩大范围以适应全屏模式
                       x <= window.innerWidth + 500 && 
                       y <= window.innerHeight + 500;
            }
            
            // 设置校准偏移
            setCalibrationOffset(offsetX, offsetY) {
                this.calibrationOffset.x = offsetX;
                this.calibrationOffset.y = offsetY;
                debug(`设置校准偏移: x=${offsetX}, y=${offsetY}`);
            }
            
            // 设置全屏偏移
            setFullscreenOffset(offsetX, offsetY) {
                this.fullscreenOffset.x = offsetX;
                this.fullscreenOffset.y = offsetY;
                debug(`设置全屏偏移: x=${offsetX}, y=${offsetY}`);
            }
        }

        // ===========================================
        // 热力图管理器
        // ===========================================
        class HeatmapManager {
            constructor() {
                this.dataPoints = [];
                this.currentInstance = null;
                this.lastInstanceConfig = null;
            }
            
            // 初始化热力图实例
            initialize() {
                const container = document.getElementById('heatmapContainer');
                const config = this.generateOptimalConfig();
                
                this.currentInstance = h337.create(config);
                this.lastInstanceConfig = config;
                
                debug(`热力图初始化: ${config.radius}px半径, ${container.offsetWidth}x${container.offsetHeight}`);
                return this.currentInstance;
            }
            
            // 无损重新初始化热力图
            reinitializeForFullscreen() {
                debug('开始重新初始化热力图以适应全屏...');
                
                // 保存当前数据点
                const currentData = [...this.dataPoints];
                debug(`保存 ${currentData.length} 个历史数据点`);
                
                // 更新容器尺寸
                this.updateContainerSize();
                
                // 重新创建实例
                this.currentInstance = null;
                this.initialize();
                
                // 重新应用历史数据
                this.reapplyHistoricalData(currentData);
                
                debug('热力图重新初始化完成');
            }
            
            // 更新容器尺寸
            updateContainerSize() {
                const container = document.getElementById('heatmapContainer');
                container.style.width = window.innerWidth + 'px';
                container.style.height = window.innerHeight + 'px';
                debug(`热力图容器尺寸更新: ${window.innerWidth}x${window.innerHeight}`);
            }
            
            // 重新应用历史数据
            reapplyHistoricalData(dataPoints) {
                if (!this.currentInstance || dataPoints.length === 0) return;
                
                debug(`重新应用 ${dataPoints.length} 个历史数据点...`);
                
                let validPointsCount = 0;
                dataPoints.forEach(point => {
                    // 重新转换坐标（如果需要）
                    const transformed = coordinateTransformer.transform(point.originalX, point.originalY);
                    
                    if (transformed && this.isPointInValidRange(transformed.x, transformed.y)) {
                        this.currentInstance.addData({
                            x: transformed.x,
                            y: transformed.y,
                            value: point.value
                        });
                        validPointsCount++;
                    }
                });
                
                debug(`成功重新应用 ${validPointsCount} 个有效数据点`);
            }
            
            // 添加数据点
            addDataPoint(x, y, value, originalX, originalY) {
                if (!this.currentInstance) {
                    debug('热力图实例未初始化，跳过数据点添加');
                    return false;
                }
                
                // 验证坐标有效性
                if (!this.isPointInValidRange(x, y)) {
                    debug(`数据点超出有效范围: (${x}, ${y})`);
                    return false;
                }
                
                // 存储数据点（包含原始坐标）
                const dataPoint = {
                    x, y, value,
                    originalX: originalX || x,
                    originalY: originalY || y,
                    timestamp: Date.now(),
                    isFullscreen: document.fullscreenElement !== null
                };
                
                this.dataPoints.push(dataPoint);
                
                // 添加到热力图
                this.currentInstance.addData({ x, y, value });
                
                // 限制历史数据点数量，防止内存泄漏
                if (this.dataPoints.length > 10000) {
                    this.dataPoints = this.dataPoints.slice(-8000); // 保留最新的8000个点
                    debug('清理历史数据点，保留最新8000个');
                }
                
                return true;
            }
            
            // 验证点是否在有效范围内
            isPointInValidRange(x, y) {
                return x >= -50 && y >= -50 && 
                       x <= window.innerWidth + 50 && 
                       y <= window.innerHeight + 50;
            }
            
            // 生成最优配置
            generateOptimalConfig() {
                const radius = Math.max(20, Math.min(50, window.innerWidth / 40));
                
                return {
                    container: document.getElementById('heatmapContainer'),
                    radius: radius,
                    maxOpacity: 0.7,
                    minOpacity: 0.1,
                    blur: 0.8,
                    gradient: {
                        0.0: 'rgba(0,0,255,0)',
                        0.3: 'rgba(0,255,0,0.5)',
                        0.6: 'rgba(255,255,0,0.7)',
                        1.0: 'rgba(255,0,0,1)'
                    }
                };
            }
            
            // 获取数据点统计
            getStatistics() {
                return {
                    totalPoints: this.dataPoints.length,
                    fullscreenPoints: this.dataPoints.filter(p => p.isFullscreen).length,
                    windowedPoints: this.dataPoints.filter(p => !p.isFullscreen).length,
                    timeRange: this.dataPoints.length > 0 ? {
                        start: this.dataPoints[0].timestamp,
                        end: this.dataPoints[this.dataPoints.length - 1].timestamp
                    } : null
                };
            }
        }

        // ===========================================
        // 全屏状态管理器（增强版本）
        // ===========================================
        class FullscreenManager {
            constructor(heatmapManager, coordinateTransformer) {
                this.heatmapManager = heatmapManager;
                this.coordinateTransformer = coordinateTransformer;
                this.isTransitioning = false;
                this.preFullscreenScroll = { x: 0, y: 0 }; // 记录全屏前的滚动位置
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                // 监听多种全屏事件
                ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange']
                    .forEach(event => {
                        document.addEventListener(event, () => this.handleFullscreenChange());
                    });
                
                // 监听窗口尺寸变化
                window.addEventListener('resize', () => this.handleResize());
            }
            
            async handleFullscreenChange() {
                if (this.isTransitioning) return;
                this.isTransitioning = true;
                
                try {
                    debug('检测到全屏状态变化，等待DOM稳定...');
                    
                    // 记录全屏前的滚动位置
                    if (document.fullscreenElement !== null) {
                        this.preFullscreenScroll.x = window.scrollX;
                        this.preFullscreenScroll.y = window.scrollY;
                        debug(`记录全屏前滚动位置: (${this.preFullscreenScroll.x}, ${this.preFullscreenScroll.y})`);
                    }
                    
                    // 等待DOM稳定
                    await this.waitForDOMStable();
                    
                    // 更新状态
                    this.coordinateTransformer.isFullscreen = document.fullscreenElement !== null;
                    debug(`全屏状态更新: ${this.coordinateTransformer.isFullscreen}`);
                    
                    // 校准全屏坐标偏移
                    if (this.coordinateTransformer.isFullscreen) {
                        this.calibrateFullscreenOffset();
                    }
                    
                    // 重新校准坐标系统
                    this.coordinateTransformer.recalibrate();
                    
                    // 重新初始化热力图
                    this.heatmapManager.reinitializeForFullscreen();
                    
                    // 更新视频显示区域
                    updateVideoDisplayArea();
                    
                    debug('全屏状态变化处理完成');
                } finally {
                    this.isTransitioning = false;
                }
            }
            
            // 校准全屏坐标偏移
            calibrateFullscreenOffset() {
                debug('开始校准全屏坐标偏移...');
                
                // 在全屏模式下，WebGazer可能需要额外的偏移修正
                // 这里可以根据实际测试结果调整偏移值
                const offsetX = 0; // 可以根据测试结果调整
                const offsetY = 0; // 可以根据测试结果调整
                
                this.coordinateTransformer.setFullscreenOffset(offsetX, offsetY);
                
                // 可以在这里添加自动校准逻辑
                // 例如：检测屏幕中心点是否对应正确位置
                this.validateFullscreenCalibration();
            }
            
            // 验证全屏校准
            validateFullscreenCalibration() {
                if (!webgazer || !webgazer.isReady()) return;
                
                debug('验证全屏校准准确性...');
                
                // 临时设置监听器来验证坐标
                const tempListener = (data, elapsedTime) => {
                    if (data && data.x && data.y) {
                        const transformed = this.coordinateTransformer.transform(data.x, data.y);
                        if (transformed) {
                            debug(`全屏校准验证: WebGazer(${data.x}, ${data.y}) -> 转换后(${transformed.x}, ${transformed.y})`);
                            
                            // 检查转换后的坐标是否在合理范围内
                            const isValid = transformed.x >= 0 && transformed.x <= window.innerWidth &&
                                          transformed.y >= 0 && transformed.y <= window.innerHeight;
                            
                            if (!isValid) {
                                debug('⚠️ 全屏坐标转换可能有问题，请检查偏移设置');
                            } else {
                                debug('✅ 全屏坐标转换正常');
                            }
                        }
                    }
                    
                    // 只验证一次就移除监听器
                    webgazer.removeGazeListener(tempListener);
                };
                
                webgazer.setGazeListener(tempListener);
                
                // 3秒后恢复原始监听器
                setTimeout(() => {
                    if (webgazer && typeof webgazer.setGazeListener === 'function') {
                        webgazer.setGazeListener(gazeDataCallback);
                        debug('全屏校准验证完成，已恢复原始监听器');
                    }
                }, 3000);
            }
            
            handleResize() {
                if (this.isTransitioning) return;
                
                debug(`窗口尺寸变化: ${window.innerWidth}x${window.innerHeight}`);
                
                // 延迟处理，避免频繁触发
                clearTimeout(this.resizeTimeout);
                this.resizeTimeout = setTimeout(() => {
                    this.coordinateTransformer.recalibrate();
                    this.heatmapManager.updateContainerSize();
                    updateVideoDisplayArea();
                }, 200);
            }
            
            // 等待DOM稳定
            async waitForDOMStable() {
                return new Promise(resolve => {
                    let stableCount = 0;
                    let lastWidth = window.innerWidth;
                    let lastHeight = window.innerHeight;
                    
                    const checkStability = () => {
                        if (window.innerWidth === lastWidth && window.innerHeight === lastHeight) {
                            stableCount++;
                            if (stableCount >= 3) {
                                debug('DOM状态已稳定');
                                resolve();
                                return;
                            }
                        } else {
                            stableCount = 0;
                            lastWidth = window.innerWidth;
                            lastHeight = window.innerHeight;
                        }
                        
                        setTimeout(checkStability, 50);
                    };
                    
                    checkStability();
                });
            }
        }

        // ===========================================
        // 校准数据管理器
        // ===========================================
        class CalibrationManager {
            constructor() {
                this.calibrationData = new Map();
                this.currentMode = 'windowed';
            }
            
            // 保存当前模式的校准数据
            saveCalibrationForMode(mode) {
                if (webgazer && webgazer.getStoredPoints) {
                    const storedPoints = webgazer.getStoredPoints();
                    if (storedPoints && storedPoints.length > 0) {
                        this.calibrationData.set(mode, {
                            points: storedPoints,
                            screenDimensions: {
                                width: window.innerWidth,
                                height: window.innerHeight
                            },
                            timestamp: Date.now()
                        });
                        debug(`保存 ${mode} 模式校准数据`);
                    }
                }
            }
            
            // 恢复或适配校准数据
            adaptCalibrationForMode(newMode) {
                const savedData = this.calibrationData.get(newMode);
                
                if (savedData) {
                    debug(`恢复 ${newMode} 模式的校准数据`);
                    this.restoreCalibrationData(savedData);
                } else {
                    debug(`${newMode} 模式无校准数据，尝试从其他模式适配`);
                    this.adaptFromOtherMode(newMode);
                }
                
                this.currentMode = newMode;
            }
            
            // 从其他模式适配校准数据
            adaptFromOtherMode(targetMode) {
                const sourceMode = targetMode === 'fullscreen' ? 'windowed' : 'fullscreen';
                const sourceData = this.calibrationData.get(sourceMode);
                
                if (sourceData && webgazer) {
                    debug(`从 ${sourceMode} 模式适配校准数据到 ${targetMode} 模式`);
                    
                    // 计算缩放比例
                    const scaleX = window.innerWidth / sourceData.screenDimensions.width;
                    const scaleY = window.innerHeight / sourceData.screenDimensions.height;
                    
                    debug(`缩放比例: x=${scaleX.toFixed(3)}, y=${scaleY.toFixed(3)}`);
                    
                    // 设置坐标转换器的校准偏移
                    coordinateTransformer.setCalibrationOffset(
                        (scaleX - 1) * window.innerWidth * 0.1,
                        (scaleY - 1) * window.innerHeight * 0.1
                    );
                }
            }
            
            // 恢复校准数据
            restoreCalibrationData(savedData) {
                // 这里可以实现WebGazer校准数据的恢复逻辑
                // 由于WebGazer API限制，主要通过坐标转换器来实现适配
                debug('校准数据恢复完成');
            }
        }

        // ===========================================
        // 核心系统函数（保持现有）
        // ===========================================
        function debug(message) {
            const timestamp = new Date().toLocaleTimeString();
            console.log(`[DEBUG ${timestamp}] ${message}`);
            if (debugMode) {
                const debugDiv = document.getElementById('debugInfo');
                debugDiv.innerHTML = `[${timestamp}] ${message}<br>` + debugDiv.innerHTML.split('<br>').slice(0, 30).join('<br>');
            }
        }
        function updateStatus(message, type) {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = `status ${type}`;
            document.getElementById('systemStatus').textContent = message;
            debug(`状态更新: ${message}`);
        }
        function updateFirebaseStatus(message, status) {
            const el = document.getElementById('firebaseStatus');
            el.textContent = `🔥 Firebase: ${message}`;
            el.className = `firebase-status ${status}`;
        }
        function updateCollectionStatus(message, status) {
            const el = document.getElementById('collectionStatus');
            el.textContent = `📈 数据收集: ${message}`;
            el.className = `collection-status ${status}`;
        }
        
        async function testFirebaseConnection() {
            debug('开始测试Firebase连接...');
            updateFirebaseStatus('测试中...', 'uploading');
            try {
                await db.collection("video_experiment_connection_test_v1").add({ 
                    sessionId, 
                    userId, 
                    timestamp: new Date().toISOString(),
                    experimentType: 'video_eye_tracking'
                });
                debug('Firebase连接测试成功！');
                updateFirebaseStatus('连接正常', 'connected');
                firebaseConnected = true;
                swal('成功', `Firebase连接测试成功！\n用户ID: ${userId}`, 'success');
            } catch (error) {
                console.error("Firebase Connection Test Failed: ", error);
                debug(`Firebase连接测试失败: ${error.message}`);
                updateFirebaseStatus('连接失败', 'disconnected');
                firebaseConnected = false;
                swal('失败', `Firebase连接测试失败！\n\n${error.message}`, 'error');
            }
        }
        async function forceSaveData() {
            if (!isTracking) return swal('提示', '请先启动眼动追踪。', 'info');
            await saveEyeTrackingData(true);
        }
        
        // ===========================================
        // 视频处理逻辑
        // ===========================================
        function setupVideoPlayer() {
            const videoPlayer = document.getElementById('eyeTrackingVideoPlayer');
            
            // 禁用视频默认控制
            videoPlayer.controls = false;
            videoPlayer.controlsList = "nodownload nofullscreen noremoteplayback";
            videoPlayer.disablePictureInPicture = true;
            
            // 添加视频加载事件监听
            videoPlayer.addEventListener('loadedmetadata', () => {
                debug(`视频元数据加载完成: ${videoPlayer.videoWidth}x${videoPlayer.videoHeight}`);
            });
            
            videoPlayer.addEventListener('canplay', () => {
                debug('视频可以开始播放');
            });
            
            videoPlayer.addEventListener('error', (e) => {
                debug(`视频加载错误: ${e.message}`);
            });
            
            // 视频播放和暂停事件
            videoPlayer.onplay = () => {
                debug(`视频开始播放，当前时间: ${videoPlayer.currentTime.toFixed(2)}s`);
                isVideoExperimentActive = true;
                startVideoInfoUpdate(); // 开始更新视频信息显示
                debug(`isVideoExperimentActive 设置为: ${isVideoExperimentActive}`);
            };
            
            videoPlayer.onpause = () => {
                debug(`视频已暂停，当前时间: ${videoPlayer.currentTime.toFixed(2)}s`);
                isVideoExperimentActive = false;
                stopVideoInfoUpdate(); // 停止更新视频信息显示
                debug(`isVideoExperimentActive 设置为: ${isVideoExperimentActive}`);
            };

            videoPlayer.onended = () => {
                debug('视频播放结束');
                isVideoExperimentActive = false;
                stopVideoInfoUpdate(); // 停止更新视频信息显示
                exitFullscreen();
                swal('实验结束', '视频播放已结束，眼动数据收集完成！', 'success');
            };

            // 防止用户手动操作视频
            videoPlayer.addEventListener('seeking', (e) => {
                if (isVideoExperimentActive) {
                    e.preventDefault();
                    debug('阻止用户拖动进度条');
                }
            });

            videoPlayer.addEventListener('contextmenu', (e) => {
                e.preventDefault(); // 禁用右键菜单
            });

            debug("视频播放器已准备就绪。");
        }

        // 视频信息更新相关函数
        let videoInfoInterval = null;

        function startVideoInfoUpdate() {
            if (videoInfoInterval) clearInterval(videoInfoInterval);
            videoInfoInterval = setInterval(updateVideoInfo, 100); // 每100ms更新一次
        }

        function stopVideoInfoUpdate() {
            if (videoInfoInterval) {
                clearInterval(videoInfoInterval);
                videoInfoInterval = null;
            }
        }

        function updateVideoInfo() {
            const videoPlayer = document.getElementById('eyeTrackingVideoPlayer');
            const timestampElement = document.getElementById('overlayTimestamp');
            if (videoPlayer && timestampElement) {
                timestampElement.textContent = videoPlayer.currentTime.toFixed(2) + 's';
            }
        }

        // 开始视频实验
        async function startVideoExperiment() {
            if (!isTracking) {
                swal('提示', '请先启动眼动追踪系统！', 'warning');
                return;
            }

            if (!webgazerReady) {
                swal('提示', '请等待眼动追踪系统准备就绪！', 'warning');
                return;
            }

            const videoPlayer = document.getElementById('eyeTrackingVideoPlayer');
            const playBtn = document.getElementById('playVideoBtn');
            
            try {
                // 重置视频到开始位置
                videoPlayer.currentTime = 0;
                
                // 先开始播放视频
                await videoPlayer.play();
                debug('视频开始播放，准备进入全屏');
                
                // 稍等片刻再进入全屏，确保视频已经开始播放
                setTimeout(async () => {
                    try {
                        await enterFullscreen(videoPlayer);
                        debug('已成功进入全屏模式');
                    } catch (error) {
                        debug(`全屏失败，继续非全屏模式: ${error.message}`);
                    }
                }, 100);
                
                // 更新按钮状态
                playBtn.textContent = '🎬 实验进行中...';
                playBtn.disabled = true;
                
                isVideoExperimentActive = true;
                debug('视频实验已开始，开始记录眼动数据');
                
            } catch (error) {
                console.error('启动视频实验失败:', error);
                debug(`启动视频实验失败: ${error.message}`);
                swal('错误', '无法启动视频实验，请检查浏览器权限！', 'error');
            }
        }

        // 进入全屏
        async function enterFullscreen(element) {
            try {
                if (element.requestFullscreen) {
                    await element.requestFullscreen();
                } else if (element.webkitRequestFullscreen) {
                    await element.webkitRequestFullscreen();
                } else if (element.msRequestFullscreen) {
                    await element.msRequestFullscreen();
                }
                debug('已进入全屏模式');
                
                // 全屏后需要重新初始化热力图以匹配新的尺寸
                setTimeout(() => {
                    updateHeatmapForFullscreen();
                }, 500);
                
            } catch (error) {
                debug(`全屏模式失败: ${error.message}`);
                throw error;
            }
        }

        // 更新热力图配置以适应全屏
        function updateHeatmapForFullscreen() {
            // 这个函数现在由HeatmapManager处理
            if (heatmapManager) {
                heatmapManager.reinitializeForFullscreen();
            }
        }

        // 退出全屏
        function exitFullscreen() {
            try {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
                
                // 重置按钮状态
                const playBtn = document.getElementById('playVideoBtn');
                playBtn.textContent = '▶️ 开始视频实验';
                playBtn.disabled = false;
                
                debug('已退出全屏模式');
            } catch (error) {
                debug(`退出全屏失败: ${error.message}`);
            }
        }

        // 添加测试视频截图的函数
        function testVideoCapture() {
            const video = document.getElementById('eyeTrackingVideoPlayer');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = video.videoWidth || video.offsetWidth;
            canvas.height = video.videoHeight || video.offsetHeight;
            
            try {
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                const dataURL = canvas.toDataURL('image/png');
                
                // 创建一个新窗口显示截图
                const win = window.open();
                win.document.write(`<img src="${dataURL}" style="max-width: 100%;">`);
                debug('视频截图测试成功');
                return true;
            } catch (e) {
                debug(`视频截图测试失败: ${e.message}`);
                return false;
            }
        }

        // 测试覆盖层可见性的函数
        function testOverlayVisibility() {
            const videoInfoOverlay = document.getElementById('videoInfoOverlay');
            const currentVisibility = videoInfoOverlay.style.visibility;
            
            debug(`当前覆盖层可见性: ${currentVisibility}`);
            
            // 切换可见性进行测试
            if (currentVisibility === 'hidden' || currentVisibility === '') {
                videoInfoOverlay.style.visibility = 'visible';
                updateVideoInfo(); // 确保内容是最新的
                debug('覆盖层已显示用于测试');
                setTimeout(() => {
                    videoInfoOverlay.style.visibility = 'hidden';
                    debug('覆盖层已重新隐藏');
                }, 3000);
            } else {
                videoInfoOverlay.style.visibility = 'hidden';
                debug('覆盖层已隐藏');
            }
        }

        // 测试数据收集功能
        function testDataCollection() {
            debug('开始测试数据收集功能...');
            
            // 模拟一些测试数据
            const videoPlayer = document.getElementById('eyeTrackingVideoPlayer');
            const currentTime = videoPlayer.currentTime || 5.25; // 如果视频未播放，使用测试时间
            
            // 创建测试注视点数据
            for (let i = 0; i < 10; i++) {
                const testGazePoint = {
                    x: 500 + i * 10,
                    y: 300 + i * 5,
                    timestamp: new Date().toISOString(),
                    elapsedTime: Date.now() - startTime,
                    sessionId,
                    userId,
                    videoTimestamp: parseFloat((currentTime + i * 0.1).toFixed(4)),
                    relativeX: 400 + i * 10,
                    relativeY: 200 + i * 5,
                    isVideoActive: true
                };
                
                eyeTrackingData.gazePoints.push(testGazePoint);
                gazeCount++;
            }
            
            // 创建测试眼跳数据
            const testSaccade = {
                startPoint: { x: 500, y: 300 },
                endPoint: { x: 600, y: 350 },
                distance: 111,
                duration: 45,
                velocity: 2467,
                sessionId,
                userId,
                isVideoActive: true,
                startVideoTimestamp: currentTime,
                endVideoTimestamp: currentTime + 0.045
            };
            eyeTrackingData.saccades.push(testSaccade);
            saccadeCount++;
            
            // 创建测试注视数据
            const testFixation = {
                startPoint: { x: 520, y: 310 },
                endPoint: { x: 525, y: 315 },
                centerPoint: { x: 523, y: 313 },
                duration: 250,
                startTime: new Date().toISOString(),
                pointCount: 15,
                sessionId,
                userId,
                isVideoActive: true,
                videoTimestamp: currentTime,
                endVideoTimestamp: currentTime + 0.25
            };
            eyeTrackingData.fixations.push(testFixation);
            fixationCount++;
            totalFixationTime += testFixation.duration;
            
            updateStatsDisplay();
            debug(`测试数据已添加 - 注视点: ${eyeTrackingData.gazePoints.length}, 眼跳: ${eyeTrackingData.saccades.length}, 注视: ${eyeTrackingData.fixations.length}`);
            
            // 立即尝试保存数据
            saveEyeTrackingData(true);
            
            swal('测试完成', `已添加测试数据并尝试保存：\n注视点: ${eyeTrackingData.gazePoints.length}\n眼跳: ${eyeTrackingData.saccades.length}\n注视: ${eyeTrackingData.fixations.length}`, 'info');
        }

        // 测试全屏截图功能
        function testFullscreenCapture() {
            const isFullscreen = document.fullscreenElement !== null || 
                               document.webkitFullscreenElement !== null || 
                               document.mozFullScreenElement !== null ||
                               document.msFullscreenElement !== null;
            
            if (!isFullscreen) {
                swal('提示', '请先进入全屏模式（点击"开始视频实验"按钮）再测试截图功能', 'info');
                return;
            }
            
            debug('开始测试全屏截图功能...');
            
            // 立即触发一次热力图截图
            if (heatmapInstance && isTracking && isVideoExperimentActive) {
                captureHeatmapSnapshot();
                swal('测试', '已触发全屏热力图截图，请查看调试信息和Cloudinary', 'info');
            } else {
                swal('错误', '请确保眼动追踪已启动且视频实验正在进行', 'error');
            }
        }

        // ===========================================
        // 改进的眼动数据处理流程
        // ===========================================
        function gazeDataCallback(data, elapsedTime) {
            // 基础验证
            if (!isTracking || isCalibrating || !data || !isVideoExperimentActive) return;
            
            // 原始数据验证
            if (!coordinateTransformer.isValidCoordinate(data.x, data.y)) {
                if (gazeCount % 100 === 0) {
                    debug(`无效的WebGazer坐标: (${data.x}, ${data.y})`);
                }
                return;
            }
            
            // 坐标转换
            const transformedPoint = coordinateTransformer.transform(data.x, data.y);
            if (!transformedPoint) {
                debug(`坐标转换失败: (${data.x}, ${data.y})`);
                return;
            }
            
            const timestamp = new Date().toISOString();
            const videoPlayer = document.getElementById('eyeTrackingVideoPlayer');
            const isFullscreen = document.fullscreenElement !== null;
            
            // 视频区域映射
            const videoMapping = calculateVideoMapping(transformedPoint);
            
            // 创建标准化的注视点数据
            const gazePoint = {
                x: transformedPoint.x,
                y: transformedPoint.y,
                timestamp,
                elapsedTime: elapsedTime || Date.now() - startTime,
                sessionId,
                userId,
                videoTimestamp: null,
                relativeX: null,
                relativeY: null,
                isVideoActive: isVideoExperimentActive,
                isFullscreen: isFullscreen,
                videoDisplayArea: {...videoDisplayArea},
                rawWebgazerX: data.x,
                rawWebgazerY: data.y,
                transformationApplied: transformedPoint.applied,
                validForHeatmap: false
            };
            
            // 视频时间戳关联
            if (videoPlayer && !videoPlayer.paused && videoPlayer.currentTime > 0 && isVideoExperimentActive) {
                gazePoint.videoTimestamp = parseFloat(videoPlayer.currentTime.toFixed(4));
                
                // 计算相对于视频显示区域的坐标
                if (videoMapping && videoMapping.isInVideoArea) {
                    gazePoint.relativeX = videoMapping.relativeX;
                    gazePoint.relativeY = videoMapping.relativeY;
                    gazePoint.videoNormalizedX = videoMapping.normalizedX;
                    gazePoint.videoNormalizedY = videoMapping.normalizedY;
                    gazePoint.validForHeatmap = true;
                    
                    // 添加到热力图（只有在视频区域内的点）
                    heatmapManager.addDataPoint(
                        transformedPoint.x,
                        transformedPoint.y,
                        5,
                        data.x,
                        data.y
                    );
                    
                    // 调试信息（减少频率）
                    if (gazeCount % 200 === 0) {
                        debug(`注视点: WebGazer(${data.x.toFixed(1)}, ${data.y.toFixed(1)}) -> 转换后(${transformedPoint.x}, ${transformedPoint.y}) -> 视频相对(${gazePoint.relativeX}, ${gazePoint.relativeY})`);
                    }
                } else {
                    // 调试不在视频区域内的点
                    if (gazeCount % 500 === 0) {
                        debug(`注视点在视频区域外: 转换后(${transformedPoint.x}, ${transformedPoint.y}), 视频区域: ${videoDisplayArea.x}-${videoDisplayArea.x + videoDisplayArea.width}, ${videoDisplayArea.y}-${videoDisplayArea.y + videoDisplayArea.height}`);
                    }
                }
            }
            
            // 处理眼跳和注视
            processSaccadeAndFixation(gazePoint);
            
            // 存储数据
            eyeTrackingData.gazePoints.push(gazePoint);
            gazeCount++;
            
            if (gazeCount % 50 === 0) {
                updateStatsDisplay();
                debug(`已记录 ${gazeCount} 个注视点`);
            }
        }
        
        // 计算视频映射
        function calculateVideoMapping(transformedPoint) {
            const relX = transformedPoint.x - videoDisplayArea.x;
            const relY = transformedPoint.y - videoDisplayArea.y;
            
            const isInVideoArea = relX >= 0 && relX <= videoDisplayArea.width && 
                                 relY >= 0 && relY <= videoDisplayArea.height;
            
            if (!isInVideoArea) {
                return { isInVideoArea: false };
            }
            
            return {
                isInVideoArea: true,
                relativeX: Math.floor(relX),
                relativeY: Math.floor(relY),
                normalizedX: relX / videoDisplayArea.width,
                normalizedY: relY / videoDisplayArea.height
            };
        }

        // 更新视频显示区域计算
        function updateVideoDisplayArea() {
            const videoPlayer = document.getElementById('eyeTrackingVideoPlayer');
            const isFullscreen = document.fullscreenElement !== null;
            
            if (isFullscreen && videoPlayer.videoWidth > 0 && videoPlayer.videoHeight > 0) {
                videoDisplayArea = calculateFullscreenVideoArea(videoPlayer);
            } else {
                const rect = videoPlayer.getBoundingClientRect();
                videoDisplayArea = {
                    x: rect.left,
                    y: rect.top,
                    width: rect.width,
                    height: rect.height
                };
            }
            
            debug(`视频显示区域更新: ${videoDisplayArea.x}, ${videoDisplayArea.y}, ${videoDisplayArea.width}x${videoDisplayArea.height}`);
        }
        
        function calculateFullscreenVideoArea(videoPlayer) {
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            const videoAspect = videoPlayer.videoWidth / videoPlayer.videoHeight;
            const screenAspect = screenWidth / screenHeight;
            
            let area;
            if (videoAspect > screenAspect) {
                area = {
                    width: screenWidth,
                    height: screenWidth / videoAspect,
                    x: 0,
                    y: (screenHeight - screenWidth / videoAspect) / 2
                };
            } else {
                area = {
                    height: screenHeight,
                    width: screenHeight * videoAspect,
                    x: (screenWidth - screenHeight * videoAspect) / 2,
                    y: 0
                };
            }
            
            return area;
        }

        // ===========================================
        // 测试和调试函数（增强版本）
        // ===========================================
        function testCoordinateTransform() {
            if (!coordinateTransformer) {
                swal('错误', '坐标转换器未初始化', 'error');
                return;
            }
            
            debug('开始坐标转换测试...');
            
            // 测试几个关键位置
            const testPoints = [
                { x: 0, y: 0, name: '左上角' },
                { x: window.innerWidth / 2, y: window.innerHeight / 2, name: '中心' },
                { x: window.innerWidth, y: window.innerHeight, name: '右下角' },
                { x: videoDisplayArea.x + videoDisplayArea.width / 2, y: videoDisplayArea.y + videoDisplayArea.height / 2, name: '视频中心' }
            ];
            
            let results = '坐标转换测试结果:\n\n';
            results += `当前模式: ${document.fullscreenElement !== null ? '全屏' : '窗口'}\n`;
            results += `屏幕尺寸: ${window.innerWidth}x${window.innerHeight}\n`;
            results += `视频区域: ${videoDisplayArea.x}, ${videoDisplayArea.y}, ${videoDisplayArea.width}x${videoDisplayArea.height}\n\n`;
            
            testPoints.forEach(point => {
                const transformed = coordinateTransformer.transform(point.x, point.y);
                if (transformed) {
                    results += `${point.name}: (${point.x}, ${point.y}) -> (${transformed.x}, ${transformed.y})\n`;
                    results += `  应用变换: ${JSON.stringify(transformed.applied)}\n`;
                } else {
                    results += `${point.name}: (${point.x}, ${point.y}) -> 转换失败\n`;
                }
            });
            
            const stats = heatmapManager.getStatistics();
            results += `\n热力图统计:\n总点数: ${stats.totalPoints}\n全屏点数: ${stats.fullscreenPoints}\n窗口点数: ${stats.windowedPoints}`;
            
            debug(results);
            swal('坐标转换测试', results, 'info');
        }
        
        function forceRecalibrate() {
            debug('开始强制重校准...');
            
            if (coordinateTransformer) {
                coordinateTransformer.recalibrate();
            }
            
            if (heatmapManager) {
                heatmapManager.reinitializeForFullscreen();
            }
            
            updateVideoDisplayArea();
            
            debug('强制重校准完成');
            swal('重校准', '坐标系统已重新校准', 'success');
        }

        function testGazeMapping() {
            debug('开始注视映射测试...');
            testCoordinateTransform();
        }

        // =======================================================================
        // 校准与精度测试流程
        // =======================================================================
        
        function ClearCanvas(){
            document.querySelectorAll('.Calibration').forEach((i) => { i.style.display = 'none'; });
            var canvas = document.getElementById("plotting_canvas");
            canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
        }
        
        function PopUpInstruction() {
            if (!isTracking) return swal('提示', '请先启动眼动追踪。', 'info');
            
            // 设置校准状态标志
            isCalibrating = true;
            
            document.getElementById('statsPanel').style.display = 'none';
            // 隐藏控制按钮避免遮挡校准点
            document.querySelector('.controls').style.display = 'none';
            ClearCanvas();
            swal({
                title:"校准说明",
                text: "请点击屏幕上出现的9个点。您必须在每个点上点击5次，直到它变成黄色。这将校准您的眼动追踪。",
                buttons:{ cancel: false, confirm: "开始" }
            }).then(() => {
                updateStatus('校准进行中', 'calibrating');
                debug('开始9点校准流程');
                ShowCalibrationPoint();
                document.querySelectorAll('.Calibration').forEach((i) => { i.onclick = () => calPointClick(i); });
            });
        }
        
        function ShowCalibrationPoint() {
            document.querySelectorAll('.Calibration').forEach((i) => { i.style.display = 'block'; });
            document.getElementById('Pt5').style.display = 'none';
        }
        
        function calPointClick(node) {
            const id = node.id;
            if (!CalibrationPoints[id]) CalibrationPoints[id] = 0;
            CalibrationPoints[id]++; 
            node.style.opacity = 0.2 * CalibrationPoints[id] + 0.2;
            if (CalibrationPoints[id] == 5) {
                node.style.backgroundColor = 'yellow';
                node.setAttribute('disabled', 'disabled');
                PointCalibrate++;
                debug(`校准点 ${id} 完成，当前完成数量: ${PointCalibrate}`);
                
                // 前8个点点击完后，显示Pt5
                if (PointCalibrate === 8) {
                    document.getElementById('Pt5').style.display = 'block';
                    debug('显示第9个校准点 Pt5');
                }
                // 只有Pt5点击完才进入精度计算
                if (PointCalibrate === 9) {
                    debug('所有校准点完成，开始精度计算');
                    document.querySelectorAll('.Calibration').forEach((i) => { if(i.id !== 'Pt5') i.style.display = 'none'; });
                    calcAccuracy();
                }
            }
        }

        function calcAccuracy() {
            swal({
                title: "正在计算精度",
                text: "请不要移动您的鼠标，并尽力注视屏幕中央的点5秒钟。这将帮助我们计算预测的准确性。",
                closeOnEsc: false, allowOutsideClick: false, closeModal: true
            }).then(() => {
                updateStatus('精度测试中...', 'calibrating');
                if (webgazer) webgazer.params.storingPoints = true;
                sleep(5000).then(() => {
                    if (webgazer) webgazer.params.storingPoints = false;
                    var past50 = webgazer.getStoredPoints();
                    var precisionPercentage = calculatePrecision(past50);
                    
                    document.getElementById('Accuracy').innerHTML = `测试精度: ${precisionPercentage}%`;
                    eyeTrackingData.calibrationData = {
                        points: CalibrationPoints,
                        accuracyPercentage: precisionPercentage,
                        timestamp: new Date().toISOString()
                    };
                    
                    swal({
                        title: `您的追踪精度为 ${precisionPercentage}%`,
                        allowOutsideClick: false,
                        buttons: { cancel: "重新校准", confirm: "接受" }
                    }).then(isConfirm => {
                        document.getElementById('statsPanel').style.display = 'block';
                        // 恢复显示控制按钮
                        document.querySelector('.controls').style.display = 'block';
                        if (isConfirm) {
                            ClearCanvas();
                            updateStatus('运行中', 'ready');
                            // 校准完成，重置校准状态
                            isCalibrating = false;
                        } else {
                            document.getElementById("Accuracy").innerHTML = "等待校准...";
                            webgazer.clearData();
                            Restart();
                        }
                    });
                });
            });
        }
        
        function sleep(time) { return new Promise((resolve) => setTimeout(resolve, time)); }
        
        function calculatePrecision(past50Array) {
          var windowHeight = window.innerHeight;
          var staringPointX = window.innerWidth / 2;
          var staringPointY = windowHeight / 2;
          var x50 = past50Array[0];
          var y50 = past50Array[1];
          var precisionPercentages = new Array(50);
          for (let x = 0; x < 50; x++) {
            var xDiff = staringPointX - x50[x];
            var yDiff = staringPointY - y50[x];
            var distance = Math.sqrt((xDiff * xDiff) + (yDiff * yDiff));
            var halfWindowHeight = windowHeight / 2;
            var precision = 100 - (distance / halfWindowHeight * 100);
            precisionPercentages[x] = Math.max(0, precision);
          }
          return Math.round(precisionPercentages.reduce((a, b) => a + b, 0) / 50);
        };

        function Restart() {
            if (!webgazerReady) return;
            document.getElementById('Accuracy').innerHTML = "等待校准...";
            if(webgazer) webgazer.clearData();
            ClearCalibration();
            ClearCanvas();
            updateStatus('准备重新校准', 'ready');
            // 确保重新校准时也隐藏控制按钮
            document.querySelector('.controls').style.display = 'none';
            PopUpInstruction();
        }

        function ClearCalibration() {
            document.querySelectorAll('.Calibration').forEach((i) => {
                i.style.backgroundColor = 'red';
                i.style.opacity = '0.2';
                i.removeAttribute('disabled');
            });
            CalibrationPoints = {};
            PointCalibrate = 0;
        }

        // =======================================================================
        // 系统控制与生命周期
        // =======================================================================

        function toggleDebug() { debugMode = !debugMode; document.getElementById('debugPanel').style.display = debugMode ? 'block' : 'none'; }
        
        function toggleHeatmap() { 
            const heatmapContainer = document.getElementById('heatmapContainer');
            heatmapContainer.classList.toggle('heatmap-visible');
            heatmapContainer.style.visibility = heatmapContainer.classList.contains('heatmap-visible') ? 'visible' : 'hidden';
        }
        
        function startStatsUpdate() {
            if (statsUpdateInterval) clearInterval(statsUpdateInterval);
            statsUpdateInterval = setInterval(() => { if (isTracking) { document.getElementById('runningTime').textContent = Math.round((Date.now() - startTime) / 1000) + 's'; updateStatsDisplay(); } }, 1000);
        }
        function stopStatsUpdate() { if (statsUpdateInterval) clearInterval(statsUpdateInterval); }
        
        function exportData() {
            if (gazeCount === 0) return swal('无数据', '沒有可导出的数据。', 'warning');
            const dataStr = JSON.stringify({ sessionInfo: { sessionId, userId }, collectedData: eyeTrackingData }, null, 2);
            const link = document.createElement('a');
            link.href = URL.createObjectURL(new Blob([dataStr], {type: 'application/json'}));
            link.download = `eye-tracking-data-${sessionId}.json`;
            link.click();
            URL.revokeObjectURL(link.href);
        }

        // ===========================================
        // 数据处理和保存函数
        // ===========================================
        function processSaccadeAndFixation(gazePoint) {
            // 校准期间或视频未激活时不处理眼跳和注视数据
            if (isCalibrating || !isVideoExperimentActive) return;
            
            if (!lastGazePoint) {
                lastGazePoint = gazePoint;
                currentFixation = { 
                    startPoint: {...gazePoint}, 
                    startTime: gazePoint.timestamp, 
                    pointCount: 1, 
                    sessionId, 
                    userId, 
                    isVideoActive: isVideoExperimentActive,
                    videoTimestamp: gazePoint.videoTimestamp
                };
                return;
            }
            const distance = Math.sqrt(Math.pow(gazePoint.x - lastGazePoint.x, 2) + Math.pow(gazePoint.y - lastGazePoint.y, 2));
            if (distance > fixationThreshold) {
                if (currentFixation && currentFixation.pointCount > 1) {
                    const duration = new Date(gazePoint.timestamp).getTime() - new Date(currentFixation.startTime).getTime();
                    if (duration > fixationTimeThreshold) {
                        currentFixation.duration = duration;
                        currentFixation.endPoint = {...lastGazePoint};
                        currentFixation.centerPoint = { 
                            x: Math.round((currentFixation.startPoint.x + currentFixation.endPoint.x) / 2), 
                            y: Math.round((currentFixation.startPoint.y + currentFixation.endPoint.y) / 2) 
                        };
                        currentFixation.endVideoTimestamp = lastGazePoint.videoTimestamp;
                        eyeTrackingData.fixations.push({...currentFixation});
                        fixationCount++;
                        totalFixationTime += duration;
                    }
                }
                const saccadeDuration = new Date(gazePoint.timestamp).getTime() - new Date(lastGazePoint.timestamp).getTime();
                eyeTrackingData.saccades.push({ 
                    startPoint: {...lastGazePoint}, 
                    endPoint: {...gazePoint}, 
                    distance: Math.round(distance), 
                    duration: saccadeDuration, 
                    velocity: saccadeDuration > 0 ? Math.round(distance / saccadeDuration * 1000) : 0, 
                    sessionId, 
                    userId,
                    isVideoActive: isVideoExperimentActive,
                    startVideoTimestamp: lastGazePoint.videoTimestamp,
                    endVideoTimestamp: gazePoint.videoTimestamp
                });
                saccadeCount++;
                currentFixation = { 
                    startPoint: {...gazePoint}, 
                    startTime: gazePoint.timestamp, 
                    pointCount: 1, 
                    sessionId, 
                    userId, 
                    isVideoActive: isVideoExperimentActive,
                    videoTimestamp: gazePoint.videoTimestamp
                };
            } else {
                if (currentFixation) currentFixation.pointCount++;
            }
            lastGazePoint = gazePoint;
        }

        function updateStatsDisplay() {
            document.getElementById('totalGazes').textContent = gazeCount;
            document.getElementById('saccadeCount').textContent = saccadeCount;
            document.getElementById('fixationCount').textContent = fixationCount;
            document.getElementById('heatmapSnapshots').textContent = heatmapSnapshotCount;
            document.getElementById('snapshotCount').textContent = snapshotCount;
            document.getElementById('avgFixationTime').textContent = (fixationCount > 0 ? Math.round(totalFixationTime / fixationCount) : 0) + 'ms';
        }

        function startAutoSave() {
            if (autoSaveInterval) clearInterval(autoSaveInterval);
            autoSaveInterval = setInterval(() => saveEyeTrackingData(false), 5000);
            updateCollectionStatus('进行中 (自动)', 'connected');
            debug('自动保存已启动，间隔5秒');
        }

        function stopAutoSave() { 
            if (autoSaveInterval) {
                clearInterval(autoSaveInterval); 
                autoSaveInterval = null;
                debug('自动保存已停止');
            }
        }

        async function saveEyeTrackingData(isManual = false) {
            if (!firebaseConnected) { 
                if(isManual) swal('错误', 'Firebase未连接，无法保存。', 'error'); 
                return; 
            }
            
            const totalPoints = eyeTrackingData.gazePoints.length + eyeTrackingData.saccades.length + eyeTrackingData.fixations.length;
            debug(`准备保存数据 - 注视点: ${eyeTrackingData.gazePoints.length}, 眼跳: ${eyeTrackingData.saccades.length}, 注视: ${eyeTrackingData.fixations.length}, 总计: ${totalPoints}`);
            
            if (totalPoints === 0) { 
                debug('没有新数据可保存');
                if(isManual) swal('提示', '没有新数据可保存。', 'info'); 
                return; 
            }

            const dataToSave = JSON.parse(JSON.stringify(eyeTrackingData));
            
            // 新的数据结构 - 不包含热力图数据，专注于眼动分析数据
            const payload = { 
                sessionId, 
                userId, 
                timestamp: new Date().toISOString(), 
                dataType: isManual ? 'manual' : 'auto',
                experimentType: 'video_eye_tracking', // 实验类型标识
                videoInfo: {
                    videoUrl: document.getElementById('eyeTrackingVideoPlayer').src,
                    videoDuration: document.getElementById('eyeTrackingVideoPlayer').duration || null
                },
                // 眼动分析数据
                gazeData: dataToSave.gazePoints,
                saccadeData: dataToSave.saccades, 
                fixationData: dataToSave.fixations,
                // 校准信息
                calibrationInfo: dataToSave.calibrationData,
                // 统计摘要
                statistics: {
                    totalGazePoints: dataToSave.gazePoints.length,
                    totalSaccades: dataToSave.saccades.length,
                    totalFixations: dataToSave.fixations.length,
                    averageFixationDuration: dataToSave.fixations.length > 0 ? 
                        Math.round(dataToSave.fixations.reduce((sum, f) => sum + f.duration, 0) / dataToSave.fixations.length) : 0,
                    sessionDuration: Date.now() - startTime

                }
            };
            
            debug(`准备上传Firebase payload:`, JSON.stringify(payload.statistics, null, 2));
            
            // 清空数据（热力图数据保持不变，继续用于后续快照）
            eyeTrackingData.gazePoints = []; 
            eyeTrackingData.saccades = []; 
            eyeTrackingData.fixations = [];
            
            updateCollectionStatus('保存中...', 'uploading');
            try {
                // 使用新的集合名称进行保存
                const docRef = await db.collection("eye_tracking_video_experiment_v1").add(payload);
                snapshotCount++;
                updateCollectionStatus('进行中 (自动)', 'connected');
                debug(`数据快照 #${snapshotCount} 保存成功到新集合 eye_tracking_video_experiment_v1, 文档ID: ${docRef.id}`);
                if(isManual) swal('成功', `数据已保存到新的实验数据集！\n文档ID: ${docRef.id}`, 'success');
            } catch (error) {
                console.error("Firebase 保存失败: ", error);
                debug(`数据保存失败: ${error.message}, 正在恢复数据...`);
                updateCollectionStatus('保存失败', 'disconnected');
                if(isManual) swal('失败', `数据保存失败！\n\n${error.message}`, 'error');
                // 恢复数据
                eyeTrackingData.gazePoints = dataToSave.gazePoints.concat(eyeTrackingData.gazePoints);
                eyeTrackingData.saccades = dataToSave.saccades.concat(eyeTrackingData.saccades);
                eyeTrackingData.fixations = dataToSave.fixations.concat(eyeTrackingData.fixations);
            }
        }
        
        function startHeatmapSnapshots() {
            if (heatmapSnapshotInterval) clearInterval(heatmapSnapshotInterval);
            heatmapSnapshotInterval = setInterval(() => { 
                // 只有在视频实验激活且追踪运行时才捕获热力图
                if (heatmapInstance && isTracking && isVideoExperimentActive) {
                    captureHeatmapSnapshot(); 
                }
            }, 2000);
            debug('热力图快照已启动，间隔2秒');
        }

        function stopHeatmapSnapshots() { 
            if (heatmapSnapshotInterval) {
                clearInterval(heatmapSnapshotInterval); 
                heatmapSnapshotInterval = null;
                debug('热力图快照已停止');
            }
        }
        
        async function captureHeatmapSnapshot() {
            const heatmapContainer = document.getElementById('heatmapContainer');
            const videoInfoOverlay = document.getElementById('videoInfoOverlay');
            const originalVisibility = heatmapContainer.style.visibility;
            const originalOverlayVisibility = videoInfoOverlay.style.visibility;
            
            try {
                // 检测是否在全屏模式
                const isFullscreen = document.fullscreenElement !== null || 
                                   document.webkitFullscreenElement !== null || 
                                   document.mozFullScreenElement !== null ||
                                   document.msFullscreenElement !== null;
                
                debug(`全屏状态检测: ${isFullscreen}`);
                
                // 如果不在全屏模式，跳过截图
                if (!isFullscreen) {
                    debug('不在全屏模式，跳过热力图截图');
                    return;
                }
                
                const originalVideo = document.getElementById('eyeTrackingVideoPlayer');
                const currentVideoTime = originalVideo.currentTime;
                
                // 创建截图Canvas - 使用实际全屏尺寸
                const screenshotCanvas = document.createElement('canvas');
                const screenshotCtx = screenshotCanvas.getContext('2d');
                screenshotCanvas.width = window.innerWidth;
                screenshotCanvas.height = window.innerHeight;
                
                debug(`截图Canvas尺寸: ${screenshotCanvas.width}x${screenshotCanvas.height}`);
                
                // 1. 绘制黑色背景
                screenshotCtx.fillStyle = '#000000';
                screenshotCtx.fillRect(0, 0, screenshotCanvas.width, screenshotCanvas.height);
                
                // 2. 直接绘制视频内容到全屏Canvas
                if (originalVideo && !originalVideo.paused && originalVideo.videoWidth > 0 && originalVideo.videoHeight > 0) {
                    // 计算视频在全屏中的显示尺寸（保持宽高比）
                    const videoAspect = originalVideo.videoWidth / originalVideo.videoHeight;
                    const screenAspect = screenshotCanvas.width / screenshotCanvas.height;
                    
                    let drawWidth, drawHeight, drawX, drawY;
                    
                    if (videoAspect > screenAspect) {
                        // 视频更宽，以宽度为准
                        drawWidth = screenshotCanvas.width;
                        drawHeight = screenshotCanvas.width / videoAspect;
                        drawX = 0;
                        drawY = (screenshotCanvas.height - drawHeight) / 2;
                    } else {
                        // 视频更高，以高度为准
                        drawHeight = screenshotCanvas.height;
                        drawWidth = screenshotCanvas.height * videoAspect;
                        drawX = (screenshotCanvas.width - drawWidth) / 2;
                        drawY = 0;
                    }
                    
                    debug(`视频绘制区域: ${drawX}, ${drawY}, ${drawWidth}x${drawHeight}`);
                    
                    // 绘制视频帧
                    screenshotCtx.drawImage(originalVideo, drawX, drawY, drawWidth, drawHeight);
                } else {
                    debug('视频未在播放或尺寸无效，绘制占位符');
                    // 绘制占位符
                    screenshotCtx.fillStyle = '#333333';
                    screenshotCtx.fillRect(0, 0, screenshotCanvas.width, screenshotCanvas.height);
                    screenshotCtx.fillStyle = '#FFFFFF';
                    screenshotCtx.font = 'bold 48px Arial';
                    screenshotCtx.textAlign = 'center';
                    screenshotCtx.fillText('视频内容', screenshotCanvas.width / 2, screenshotCanvas.height / 2);
                }
                
                // 3. 获取热力图并叠加 - 修复版本
                debug('准备获取热力图数据...');
                
                // 确保热力图容器可见以便渲染
                heatmapContainer.style.visibility = 'visible';
                
                // 等待一帧以确保热力图渲染完成
                await new Promise(resolve => requestAnimationFrame(resolve));
                
                // 获取热力图canvas
                const heatmapCanvas = heatmapContainer.querySelector('canvas');
                
                if (heatmapCanvas && heatmapCanvas.width > 0 && heatmapCanvas.height > 0) {
                    debug(`热力图Canvas尺寸: ${heatmapCanvas.width}x${heatmapCanvas.height}`);
                    
                    // 检查canvas是否有内容
                    const imageData = heatmapCanvas.getContext('2d').getImageData(0, 0, 1, 1);
                    const hasContent = imageData.data.some(value => value > 0);
                    
                    if (hasContent) {
                        debug('检测到热力图内容，正在叠加...');
                        
                        // 设置热力图透明度并绘制
                        screenshotCtx.globalAlpha = 0.8; // 设置热力图透明度
                        screenshotCtx.drawImage(heatmapCanvas, 0, 0, screenshotCanvas.width, screenshotCanvas.height);
                        screenshotCtx.globalAlpha = 1.0; // 恢复透明度
                        
                        debug('热力图叠加完成');
                    } else {
                        debug('热力图Canvas为空白，尝试强制渲染...');
                        
                        // 如果canvas为空白，尝试重新渲染热力图
                        if (heatmapManager && heatmapManager.currentInstance) {
                            debug('强制重新渲染热力图...');
                            
                            // 临时隐藏然后显示以触发重绘
                            heatmapContainer.style.display = 'none';
                            heatmapContainer.offsetHeight; // 强制重绘
                            heatmapContainer.style.display = 'block';
                            
                            // 等待重绘完成
                            await new Promise(resolve => setTimeout(resolve, 100));
                            
                            // 再次尝试获取canvas
                            const retryCanvas = heatmapContainer.querySelector('canvas');
                            if (retryCanvas) {
                                const retryImageData = retryCanvas.getContext('2d').getImageData(0, 0, 1, 1);
                                const retryHasContent = retryImageData.data.some(value => value > 0);
                                
                                if (retryHasContent) {
                                    debug('重试后检测到热力图内容，正在叠加...');
                                    screenshotCtx.globalAlpha = 0.8;
                                    screenshotCtx.drawImage(retryCanvas, 0, 0, screenshotCanvas.width, screenshotCanvas.height);
                                    screenshotCtx.globalAlpha = 1.0;
                                    debug('热力图叠加完成（重试）');
                                } else {
                                    debug('重试后热力图仍为空白');
                                }
                            }
                        }
                    }
                } else {
                    debug('热力图Canvas无效或不存在');
                    
                    // 如果没有canvas，尝试使用html2canvas作为备选方案
                    if (typeof html2canvas !== 'undefined') {
                        debug('尝试使用html2canvas获取热力图...');
                        try {
                            const canvas = await html2canvas(heatmapContainer, {
                                backgroundColor: null,
                                scale: 1,
                                useCORS: true,
                                allowTaint: true
                            });
                            
                            if (canvas && canvas.width > 0 && canvas.height > 0) {
                                debug('html2canvas成功获取热力图，正在叠加...');
                                screenshotCtx.globalAlpha = 0.8;
                                screenshotCtx.drawImage(canvas, 0, 0, screenshotCanvas.width, screenshotCanvas.height);
                                screenshotCtx.globalAlpha = 1.0;
                                debug('热力图叠加完成（html2canvas）');
                            }
                        } catch (html2canvasError) {
                            debug(`html2canvas失败: ${html2canvasError.message}`);
                        }
                    }
                }
                
                // 恢复原始可见性
                heatmapContainer.style.visibility = originalVisibility;
                
                // 4. 添加视频信息覆盖层
                videoInfoOverlay.style.visibility = 'visible';
                updateVideoInfo();
                
                // 手动绘制覆盖层信息
                screenshotCtx.font = 'bold 24px Arial';
                screenshotCtx.fillStyle = 'rgba(255, 0, 0, 0.9)';
                const overlayText = `用户: ${userId} | 时间: ${currentVideoTime.toFixed(2)}s`;
                const overlayMetrics = screenshotCtx.measureText(overlayText);
                screenshotCtx.fillRect(10, 10, overlayMetrics.width + 20, 40);
                screenshotCtx.fillStyle = 'rgba(255, 255, 255, 1)';
                screenshotCtx.fillText(overlayText, 20, 35);
                
                // 5. 转换为图片并上传
                const imageDataUrl = screenshotCanvas.toDataURL('image/png', 0.95);
                const cloudName = 'ddp3tohxk';
                const uploadPreset = 'index1';
                const url = `https://api.cloudinary.com/v1_1/${cloudName}/image/upload`;
                
                const heatmapFileName = `${userId}_${currentVideoTime.toFixed(2)}s_fullscreen_video`;
                
                debug(`准备上传全屏视频热力图，文件名: ${heatmapFileName}, 尺寸: ${screenshotCanvas.width}x${screenshotCanvas.height}`);
                
                const formData = new FormData();
                formData.append('file', imageDataUrl);
                formData.append('upload_preset', uploadPreset);
                formData.append('folder', `fullscreen_video_heatmaps/${userId}/${sessionId}`);
                formData.append('public_id', heatmapFileName);
                
                const response = await fetch(url, { method: 'POST', body: formData });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Cloudinary上传失败: ${errorData.error.message}`);
                }
                const data = await response.json();
                const secureUrl = data.secure_url;
                debug(`全屏视频热力图上传成功: ${secureUrl}`);
                
                // 保存在本地数据中
                eyeTrackingData.heatmapSnapshots.push({ 
                    timestamp: new Date().toISOString(), 
                    storageUrl: secureUrl, 
                    provider: 'cloudinary', 
                    sessionId, 
                    userId,
                    videoTimestamp: currentVideoTime,
                    videoFrameCaptured: true,
                    method: 'direct_video_canvas_with_heatmap',
                    fileName: heatmapFileName,
                    imageSize: `${screenshotCanvas.width}x${screenshotCanvas.height}`,
                    isFullscreen: true,
                    captureType: 'fullscreen_video_with_heatmap_overlay',
                    videoDisplaySize: `${originalVideo.videoWidth}x${originalVideo.videoHeight}`
                });
                heatmapSnapshotCount++;
                updateStatsDisplay();
                
            } catch (error) {
                console.error("捕获或上传全屏视频热力图快照时出错: ", error);
                debug(`捕获或上传全屏视频热力图快照时出错: ${error.message}`);
            } finally {
                // 确保恢复原始状态
                heatmapContainer.style.visibility = originalVisibility;
                videoInfoOverlay.style.visibility = originalOverlayVisibility;
            }
        }

        // 修改startEyeTracking函数中的WebGazer跟踪器设置
        async function startEyeTracking() {
            if (!librariesLoaded) return;
            const startBtn = document.getElementById('startBtn');
            startBtn.disabled = true;
            updateStatus('初始化WebGazer...', 'initializing');
            try {
                // 修复：使用正确的跟踪器名称
                await webgazer.setRegression('ridge').setTracker('TFFacemesh').setGazeListener(gazeDataCallback).begin();
                webgazer.showVideoPreview(true).showPredictionPoints(true).applyKalmanFilter(true);
                isTracking = true; startTime = Date.now(); webgazerReady = true;
                if (firebaseConnected) startAutoSave();
                startHeatmapSnapshots(); startStatsUpdate();
                updateStatus('运行中', 'ready');
                document.getElementById('calibrateBtn').disabled = false;
                startBtn.textContent = '✅ 运行中';
                swal('启动成功', '眼动追踪已启动！\n强烈建议您点击"开始校准"以提高精度。', 'success');
            } catch (error) {
                console.error("启动眼动追踪失败:", error);
                updateStatus('启动失败', 'error');
                startBtn.disabled = false;
                swal('启动失败', `无法启动眼动追踪。\n请检查摄像头权限。\n\n${error.message}`, 'error');
            }
        }

        async function performStop() {
            if (firebaseConnected) await saveEyeTrackingData(true);
            isTracking = false;
            stopAutoSave(); stopHeatmapSnapshots(); stopStatsUpdate();
            if (typeof webgazer !== 'undefined' && webgazer.isReady()) {
                webgazer.end();
                debug("WebGazer.end() 已调用，停止追踪。");
            }
            ClearCalibration();
            ClearCanvas();
            updateStatus('已停止', 'error');
            document.getElementById('startBtn').disabled = false;
            document.getElementById('startBtn').textContent = '🚀 启动眼动追踪';
            document.getElementById('calibrateBtn').disabled = true;
        }

        // ===========================================
        // 系统初始化（修复版本）
        // ===========================================
        async function initializeSystem() {
            try {
                updateStatus('正在加载依赖库...', 'loading');
                debug('开始系统初始化...');
                
                // 检查依赖库
                if (typeof h337 === 'undefined') {
                    throw new Error('热力图库(h337)加载失败');
                }
                if (typeof swal === 'undefined') {
                    throw new Error('SweetAlert库加载失败');
                }
                debug('依赖库检查完成');
                
                // 加载WebGazer
                updateStatus('正在加载WebGazer...', 'loading');
                if (!await loadWebGazerScript()) {
                    throw new Error('WebGazer加载失败');
                }
                if (typeof webgazer === 'undefined') {
                    throw new Error('WebGazer对象未定义');
                }
                debug('WebGazer加载成功');
                
                // 初始化管理器
                updateStatus('正在初始化管理器...', 'loading');
                coordinateTransformer = new CoordinateTransformer();
                heatmapManager = new HeatmapManager();
                calibrationManager = new CalibrationManager();
                debug('管理器创建完成');
                
                // 初始化热力图
                updateStatus('正在初始化热力图...', 'loading');
                heatmapInstance = heatmapManager.initialize();
                debug('热力图初始化完成');
                
                // 初始化全屏管理器
                fullscreenManager = new FullscreenManager(heatmapManager, coordinateTransformer);
                debug('全屏管理器初始化完成');
                
                // 测试Firebase连接
                updateStatus('正在测试Firebase连接...', 'loading');
                await testFirebaseConnection();
                
                // 设置视频播放器
                updateStatus('正在设置视频播放器...', 'loading');
                setupVideoPlayer();
                
                // 初始化画布
                ClearCanvas();
                
                // 系统就绪
                updateStatus('系统就绪', 'ready');
                document.getElementById('startBtn').disabled = false;
                librariesLoaded = true;
                
                debug('系统初始化完成！');
                swal('系统就绪', '眼动追踪系统已准备就绪！\n请点击"启动眼动追踪"开始。', 'success');
                
            } catch (error) {
                console.error('系统初始化失败:', error);
                updateStatus('初始化失败', 'error');
                debug(`系统初始化失败: ${error.message}`);
                swal('初始化失败', `系统初始化失败:\n\n${error.message}\n\n请刷新页面重试。`, 'error');
            }
        }

        // ===========================================
        // 事件监听器和生命周期管理
        // ===========================================
        
        // 页面加载完成后初始化系统
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeSystem);
        } else {
            // 如果页面已经加载完成，直接初始化
            setTimeout(initializeSystem, 100);
        }
        
        // 全局错误处理
        window.addEventListener('error', (e) => {
            debug(`全局错误: ${e.message} at ${e.filename}:${e.lineno}`);
            console.error('全局错误:', e);
        });
        
        window.addEventListener('unhandledrejection', (e) => {
            debug(`Promise拒绝: ${e.reason}`);
            console.error('Promise拒绝:', e.reason);
        });
        
        // 页面卸载前的清理
        window.addEventListener('beforeunload', (e) => {
            if (isTracking && eyeTrackingData.gazePoints.length > 0) {
                const message = '您有未保存的数据，确定要离开吗？';
                e.returnValue = message;
                return message;
            }
        });
        
        // 页面可见性变化处理
        document.addEventListener('visibilitychange', () => {
            if (isTracking && webgazer && typeof webgazer.pause === 'function') {
                if (document.visibilityState === 'hidden') {
                    webgazer.pause();
                    debug('页面隐藏，暂停WebGazer');
                } else {
                    webgazer.resume();
                    debug('页面显示，恢复WebGazer');
                }
            }
        });

        // ===========================================
        // 调试和诊断功能
        // ===========================================
        
        function diagnoseSystem() {
            debug('开始系统诊断...');
            
            const diagnostics = {
                libraries: {
                    h337: typeof h337 !== 'undefined',
                    swal: typeof swal !== 'undefined',
                    webgazer: typeof webgazer !== 'undefined',
                    firebase: typeof firebase !== 'undefined'
                },
                managers: {
                    coordinateTransformer: coordinateTransformer !== null,
                    heatmapManager: heatmapManager !== null,
                    fullscreenManager: fullscreenManager !== null,
                    calibrationManager: calibrationManager !== null
                },
                instances: {
                    heatmapInstance: heatmapInstance !== null,
                    firebaseConnected: firebaseConnected,
                    librariesLoaded: librariesLoaded
                },
                status: {
                    isTracking: isTracking,
                    webgazerReady: webgazerReady,
                    isVideoExperimentActive: isVideoExperimentActive
                }
            };
            
            console.table(diagnostics);
            debug('系统诊断完成，详细信息请查看控制台');
            return diagnostics;
        }
        
        // 添加诊断按钮到统计面板（开发时使用）
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            const statsPanel = document.getElementById('statsPanel');
            const diagnoseBtn = document.createElement('button');
            diagnoseBtn.className = 'btn test';
            diagnoseBtn.textContent = '🔍 系统诊断';
            diagnoseBtn.style.cssText = 'width: 100%; margin-top: 4px; padding: 4px; font-size: 10px;';
            diagnoseBtn.onclick = diagnoseSystem;
            statsPanel.appendChild(diagnoseBtn);
        }
    </script>
</body>
</html>
