<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>眼动追踪数据收集系统 - 视频观看版</title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
    
    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyB6O5l6uZa-6sywCZTGRJx2CKPuq3KeBF0",
            authDomain: "index-9f58d.firebaseapp.com",
            projectId: "index-9f58d",
            storageBucket: "index-9f58d.appspot.com",
            messagingSenderId: "718279245978",
            appId: "1:718279245978:web:93a9a07473ad8d3e6a5f23"
        };
        
        // 初始化 Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        
        // 生成唯一用户ID
        const generateUniqueUserId = () => {
            const timestamp = Date.now();
            const randomStr = Math.random().toString(36).substr(2, 9);
            return `user_${timestamp}_${randomStr}`;
        };
        
        const sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        const userId = generateUniqueUserId(); // 每个用户都有唯一ID
        console.log('会话ID:', sessionId);
        console.log('用户ID:', userId);

        // 动态加载WebGazer
        async function loadWebGazerScript() {
            const sources = [
                'https://webgazer.cs.brown.edu/webgazer.js',
                'https://unpkg.com/webgazer@2.0.2/dist/webgazer.js',
                'https://cdn.jsdelivr.net/npm/webgazer@2.0.2/dist/webgazer.min.js'
            ];
            for (const source of sources) {
                try {
                    await new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = source;
                        script.onload = resolve;
                        script.onerror = () => reject(new Error(`无法从 ${source} 加载WebGazer`));
                        script.timeout = 10000;
                        document.head.appendChild(script);
                    });
                    console.log(`WebGazer从 ${source} 加载成功`);
                    return true;
                } catch (error) {
                    console.error(`加载失败: ${error.message}`);
                }
            }
            return false;
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/heatmap.js/2.0.0/heatmap.min.js"></script>
    <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body { margin: 0; padding: 0; font-family: Arial, sans-serif; background: #f0f0f0; }
        #heatmapContainer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1000; visibility: hidden; }
        #plotting_canvas { position: fixed; top: 0; left: 0; cursor: crosshair; z-index: 900; pointer-events: none; }
        #content { position: relative; z-index: 1; padding: 30px; max-width: 800px; margin: 10px auto; background: white; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        #statsPanel { 
            position: fixed; 
            top: 20px; 
            right: 20px; 
            background: rgba(0,0,0,0.85); 
            color: white; 
            padding: 10px 15px; 
            border-radius: 10px; 
            z-index: 2000; 
            width: 200px; 
            font-size: 11px;
        }
        .stat-item { 
            margin: 8px 0; 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
        }
        .stat-value { 
            font-weight: bold; 
            color: #4CAF50; 
            font-size: 10px;
        }
        #debugPanel { position: fixed; bottom: 20px; right: 20px; background: rgba(0,0,0,0.9); color: #00ff00; padding: 15px; border-radius: 8px; z-index: 2000; max-width: 350px; font-family: monospace; font-size: 12px; max-height: 300px; overflow-y: auto; display: none; }
        .controls { text-align: center; margin: 20px 0; }
        .btn { background: #4CAF50; color: white; padding: 12px 24px; border: none; border-radius: 5px; cursor: pointer; margin: 0 10px; font-size: 16px; transition: background 0.3s; }
        .btn:hover { background: #45a049; }
        .btn.danger { background: #f44336; }
        .btn.danger:hover { background: #da190b; }
        .btn:disabled { background: #ccc; cursor: not-allowed; }
        .btn.test { background: #2196F3; }
        .btn.test:hover { background: #1976D2; }
        .btn.toggle { background: #FF9800; }
        .btn.toggle:hover { background: #F57C00; }
        .status { position: fixed; top: 20px; left: 20px; padding: 10px 15px; border-radius: 20px; font-weight: bold; z-index: 2000; }
        .status.ready { background: #4CAF50; color: white; }
        .status.calibrating { background: #ff9800; color: white; }
        .status.error { background: #f44336; color: white; }
        .status.initializing { background: #2196F3; color: white; }
        .status.loading { background: #9C27B0; color: white; }
        
        #webgazerVideoContainer {
            display: block !important; 
            position: fixed !important;
            top: 10px !important;
            left: 10px !important;
            width: 320px !important;
            height: 240px !important;
            z-index: 2100 !important; /* 提高z-index确保在放大模式下可见 */
            border: 2px solid #4CAF50 !important;
            border-radius: 8px !important;
        }
        
        /* 新增：视频放大模式样式 */
        .video-enlarged {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            object-fit: contain !important;
            background: #000 !important;
            z-index: 1500 !important;
            border-radius: 0 !important;
        }
        
        /* 修改：确保视频信息覆盖层在放大模式下可见 */
        #videoInfoOverlay {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            z-index: 2200 !important; /* 确保在所有元素之上 */
            pointer-events: none;
            visibility: hidden;
            border: 2px solid white;
        }
        
        /* 新增：人脸检测边框样式 */
        .face-overlay {
            position: fixed;
            border: 3px solid #00ff00;
            background: rgba(0, 255, 0, 0.1);
            z-index: 2150 !important;
            pointer-events: none;
            border-radius: 4px;
        }
        
        /* 视频时间戳覆盖层 - 仅在热力图截图时可见 */
        #videoInfoOverlay {
            position: fixed; /* 改为 fixed 以确保在全屏时可见 */
            top: 10px;
            left: 10px;
            background: rgba(255, 0, 0, 0.9); /* 改为红色背景便于调试 */
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            z-index: 10000; /* 提高 z-index 确保在全屏时可见 */
            pointer-events: none;
            visibility: hidden; /* 默认隐藏，用户看不到 */
            border: 2px solid white; /* 添加白色边框便于识别 */
        }
        
        /* 全屏时的视频容器 */
        .video-container {
            position: relative;
            display: inline-block;
            width: 100%;
            transition: all 0.3s ease;
        }
        
        /* 新增：放大模式下的控制按钮 */
        .enlarged-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2200;
            display: none;
        }
        
        .enlarged-controls.visible {
            display: block;
        }
    </style>
</head>
<body>
    <div id="status" class="status loading">正在加载库文件...</div>
    <canvas id="plotting_canvas" width="500" height="500"></canvas>

    <div id="statsPanel">
        <h4 style="margin: 0 0 8px 0; text-align: center; color: #4CAF50; font-size: 13px;">📊 眼动数据统计</h4>
        <div class="stat-item"><span>用户ID:</span><span id="userIdDisplay" class="stat-value" style="font-size: 9px; word-break: break-all;"></span></div>
        <div class="stat-item"><span>会话ID:</span><span id="sessionIdDisplay" class="stat-value" style="font-size: 9px; word-break: break-all;"></span></div>
        <div class="stat-item"><span>注视点总数:</span><span id="totalGazes" class="stat-value">0</span></div>
        <div class="stat-item"><span>眼跳次数:</span><span id="saccadeCount" class="stat-value">0</span></div>
        <div class="stat-item"><span>注视次数:</span><span id="fixationCount" class="stat-value">0</span></div>
        <div class="stat-item"><span>平均注视时间:</span><span id="avgFixationTime" class="stat-value">0ms</span></div>
        <div class="stat-item"><span>热力图快照:</span><span id="heatmapSnapshots" class="stat-value">0</span></div>
        <div class="stat-item"><span>数据快照数:</span><span id="snapshotCount" class="stat-value">0</span></div>
        <div class="stat-item"><span>运行时间:</span><span id="runningTime" class="stat-value">0s</span></div>
        <div id="Accuracy">等待校准...</div>
        <div class="stat-item"><span>系统状态:</span><span id="systemStatus" class="stat-value">加载中</span></div>
        <div class="collection-status disconnected" id="collectionStatus">📈 数据收集: 未开始</div>
        <div class="firebase-status disconnected" id="firebaseStatus">🔥 Firebase: 未连接</div>
        <button class="btn test" onclick="testFirebaseConnection()" style="width: 100%; margin-top: 4px; padding: 4px; font-size: 10px;">🧪 测试连接</button>
        <button class="btn test" onclick="forceSaveData()" style="width: 100%; margin-top: 4px; padding: 4px; font-size: 10px;">💾 强制保存</button>
        <button class="btn toggle" onclick="toggleHeatmap()" style="width: 100%; margin-top: 4px; padding: 4px; font-size: 10px;">🔥 显示/隐藏热力图</button>
        <button class="btn test" onclick="testVideoCapture()" style="width: 100%; margin-top: 4px; padding: 4px; font-size: 10px;">📹 测试视频截图</button>
        <button class="btn test" onclick="toggleDebug()" style="width: 100%; margin-top: 4px; padding: 4px; font-size: 10px;">🐛 显示调试</button>
        <button class="btn test" onclick="testOverlayVisibility()" style="width: 100%; margin-top: 4px; padding: 4px; font-size: 10px;">👁️ 测试覆盖层</button>
        <button class="btn test" onclick="testDataCollection()" style="width: 100%; margin-top: 4px; padding: 4px; font-size: 10px;">📊 测试数据收集</button>
        <button class="btn test" onclick="testFullscreenCapture()" style="width: 100%; margin-top: 4px; padding: 4px; font-size: 10px;">🎬 测试全屏截图</button>
    </div>

    <div id="debugPanel"><div id="debugInfo">调试信息将在这里显示...</div></div>
    <div id="heatmapContainer"></div>
    
    <div class="calibrationDiv">
        <input type="button" class="Calibration" id="Pt1">
        <input type="button" class="Calibration" id="Pt2">
        <input type="button" class="Calibration" id="Pt3">
        <input type="button" class="Calibration" id="Pt4">
        <input type="button" class="Calibration" id="Pt5">
        <input type="button" class="Calibration" id="Pt6">
        <input type="button" class="Calibration" id="Pt7">
        <input type="button" class="Calibration" id="Pt8">
        <input type="button" class="Calibration" id="Pt9">
    </div>

    <div id="content">
        <div class="controls">
            <button class="btn" id="startBtn" onclick="startEyeTracking()" disabled>🚀 启动眼动追踪</button>
            <button class="btn" id="calibrateBtn" onclick="PopUpInstruction()" disabled>🎯 开始校准</button>
            <button class="btn" onclick="Restart()">🔄 重新校准</button>
            <button class="btn" onclick="exportData()">📊 导出数据</button>
        </div>

        <div style="text-align: center; margin: 20px 0; padding: 15px; background: #f2f2f2; border-radius: 8px;">
            <div class="video-container">
                <video 
                    id="eyeTrackingVideoPlayer" 
                    src="https://res.cloudinary.com/ddp3tohxk/video/upload/v1757416692/%E9%99%A2%E8%9E%A8%E4%BB%AA_bzhlgy.mp4" 
                    width="100%" 
                    crossorigin="anonymous"
                    preload="auto"
                    style="border-radius: 8px; background: #000; max-height: 400px;"
                ></video>
                <div id="videoInfoOverlay">
                    用户: <span id="overlayUserId"></span> | 时间: <span id="overlayTimestamp">0.00s</span>
                </div>
            </div>
            <div style="margin-top: 10px;">
                <button class="btn" id="playVideoBtn" onclick="startVideoExperiment()" style="font-size: 18px; padding: 15px 30px;">▶️ 开始视频实验</button>
            </div>
        </div>

    </div>

    <!-- 新增：放大模式控制按钮 -->
    <div id="enlargedControls" class="enlarged-controls">
        <button class="btn danger" onclick="exitEnlargedMode()">🔙 退出放大模式</button>
        <button class="btn" onclick="toggleVideoPlayPause()">⏯️ 播放/暂停</button>
    </div>
    
    <!-- 新增：人脸检测覆盖层容器 -->
    <div id="faceOverlayContainer"></div>

    <script>
        // ===========================================
        // 全局变量定义
        // ===========================================
        let heatmapInstance = null, gazeCount = 0, snapshotCount = 0, heatmapSnapshotCount = 0, saccadeCount = 0, fixationCount = 0, totalFixationTime = 0;
        let startTime = Date.now();
        let isTracking = false, webgazerReady = false, debugMode = false, librariesLoaded = false, firebaseConnected = false;
        let isCalibrating = false, isVideoExperimentActive = false;
        let isVideoEnlarged = false; // 新增：视频放大状态标志
        
        var PointCalibrate = 0;
        var CalibrationPoints = {};
        
        let eyeTrackingData = { gazePoints: [], saccades: [], fixations: [], heatmapSnapshots: [], calibrationData: { points: [], accuracyPercentage: null, timestamp: null } };
        let persistentHeatmapData = [];
        let allTimeGazePoints = [];

        let lastGazePoint = null, currentFixation = null;
        const fixationThreshold = 50, fixationTimeThreshold = 100;
        let autoSaveInterval = null, heatmapSnapshotInterval = null, statsUpdateInterval = null;

        // 新增：人脸检测相关变量
        let faceDetectionOverlays = [];
        let lastFacePositions = [];

        document.getElementById('sessionIdDisplay').textContent = sessionId;
        document.getElementById('userIdDisplay').textContent = userId;
        document.getElementById('overlayUserId').textContent = userId;
        
        // ===========================================
        // 核心系统函数
        // ===========================================
        function debug(message) {
            const timestamp = new Date().toLocaleTimeString();
            console.log(`[DEBUG ${timestamp}] ${message}`);
            if (debugMode) {
                const debugDiv = document.getElementById('debugInfo');
                debugDiv.innerHTML = `[${timestamp}] ${message}<br>` + debugDiv.innerHTML.split('<br>').slice(0, 30).join('<br>');
            }
        }
        function updateStatus(message, type) {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = `status ${type}`;
            document.getElementById('systemStatus').textContent = message;
            debug(`状态更新: ${message}`);
        }
        function updateFirebaseStatus(message, status) {
            const el = document.getElementById('firebaseStatus');
            el.textContent = `🔥 Firebase: ${message}`;
            el.className = `firebase-status ${status}`;
        }
        function updateCollectionStatus(message, status) {
            const el = document.getElementById('collectionStatus');
            el.textContent = `📈 数据收集: ${message}`;
            el.className = `collection-status ${status}`;
        }
        
        async function testFirebaseConnection() {
            debug('开始测试Firebase连接...');
            updateFirebaseStatus('测试中...', 'uploading');
            try {
                await db.collection("video_experiment_connection_test_v1").add({ 
                    sessionId, 
                    userId, 
                    timestamp: new Date().toISOString(),
                    experimentType: 'video_eye_tracking'
                });
                debug('Firebase连接测试成功！');
                updateFirebaseStatus('连接正常', 'connected');
                firebaseConnected = true;
                swal('成功', `Firebase连接测试成功！\n用户ID: ${userId}`, 'success');
            } catch (error) {
                console.error("Firebase Connection Test Failed: ", error);
                debug(`Firebase连接测试失败: ${error.message}`);
                updateFirebaseStatus('连接失败', 'disconnected');
                firebaseConnected = false;
                swal('失败', `Firebase连接测试失败！\n\n${error.message}`, 'error');
            }
        }
        async function forceSaveData() {
            if (!isTracking) return swal('提示', '请先启动眼动追踪。', 'info');
            await saveEyeTrackingData(true);
        }
        
        // ===========================================
        // 视频处理逻辑
        // ===========================================
        function setupVideoPlayer() {
            const videoPlayer = document.getElementById('eyeTrackingVideoPlayer');
            
            // 禁用视频默认控制
            videoPlayer.controls = false;
            videoPlayer.controlsList = "nodownload nofullscreen noremoteplayback";
            videoPlayer.disablePictureInPicture = true;
            
            // 添加视频加载事件监听
            videoPlayer.addEventListener('loadedmetadata', () => {
                debug(`视频元数据加载完成: ${videoPlayer.videoWidth}x${videoPlayer.videoHeight}`);
            });
            
            videoPlayer.addEventListener('canplay', () => {
                debug('视频可以开始播放');
            });
            
            videoPlayer.addEventListener('error', (e) => {
                debug(`视频加载错误: ${e.message}`);
            });
            
            // 修改：视频播放事件处理
            videoPlayer.onplay = () => {
                debug(`视频开始播放，当前时间: ${videoPlayer.currentTime.toFixed(2)}s`);
                isVideoExperimentActive = true;
                startVideoInfoUpdate();
                // 新增：记录视频开始时间用于精确同步
                videoPlayer._playStartTime = performance.now();
                videoPlayer._playStartVideoTime = videoPlayer.currentTime;
                debug(`视频播放同步基准: ${videoPlayer._playStartVideoTime}s`);
            };
            
            videoPlayer.onpause = () => {
                debug(`视频已暂停，当前时间: ${videoPlayer.currentTime.toFixed(2)}s`);
                isVideoExperimentActive = false;
                stopVideoInfoUpdate();
            };

            videoPlayer.onended = () => {
                debug('视频播放结束');
                isVideoExperimentActive = false;
                stopVideoInfoUpdate();
                exitEnlargedMode(); // 修改：退出放大模式而不是全屏
                swal('实验结束', '视频播放已结束，眼动数据收集完成！', 'success');
            };

            // 防止用户手动操作视频
            videoPlayer.addEventListener('seeking', (e) => {
                if (isVideoExperimentActive) {
                    e.preventDefault();
                    debug('阻止用户拖动进度条');
                }
            });

            videoPlayer.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            debug("视频播放器已准备就绪。");
        }

        // 新增：视频放大功能
        async function enterEnlargedMode(videoElement) {
            try {
                // 添加放大样式类
                videoElement.classList.add('video-enlarged');
                isVideoEnlarged = true;
                
                // 显示放大模式控制按钮
                document.getElementById('enlargedControls').classList.add('visible');
                
                // 隐藏原始控制面板（可选）
                document.getElementById('content').style.display = 'none';
                
                debug('已进入视频放大模式');
                
                // 放大后需要重新初始化热力图以匹配新的尺寸
                setTimeout(() => {
                    updateHeatmapForEnlarged();
                }, 300);
                
            } catch (error) {
                debug(`视频放大模式失败: ${error.message}`);
                throw error;
            }
        }

        // 修改：更新热力图配置以适应放大模式
        function updateHeatmapForEnlarged() {
            if (heatmapInstance) {
                debug(`更新热力图配置为放大模式尺寸: ${window.innerWidth}x${window.innerHeight}`);
                
                // 获取热力图容器并更新其尺寸
                const heatmapContainer = document.getElementById('heatmapContainer');
                heatmapContainer.style.width = window.innerWidth + 'px';
                heatmapContainer.style.height = window.innerHeight + 'px';
                
                // 重新创建热力图实例以适应新尺寸
                heatmapInstance = h337.create({ 
                    container: heatmapContainer, 
                    radius: Math.max(25, window.innerWidth / 50),
                    maxOpacity: 0.7, 
                    minOpacity: 0.1, 
                    blur: 0.8 
                });
                
                debug('热力图已更新为放大模式配置');
            }
        }

        // 新增：退出放大模式
        function exitEnlargedMode() {
            try {
                const videoPlayer = document.getElementById('eyeTrackingVideoPlayer');
                videoPlayer.classList.remove('video-enlarged');
                isVideoEnlarged = false;
                
                // 隐藏放大模式控制按钮
                document.getElementById('enlargedControls').classList.remove('visible');
                
                // 恢复显示原始内容
                document.getElementById('content').style.display = 'block';
                
                // 重置按钮状态
                const playBtn = document.getElementById('playVideoBtn');
                playBtn.textContent = '▶️ 开始视频实验';
                playBtn.disabled = false;
                
                debug('已退出放大模式');
            } catch (error) {
                debug(`退出放大模式失败: ${error.message}`);
            }
        }

        // 新增：播放/暂停控制
        function toggleVideoPlayPause() {
            const videoPlayer = document.getElementById('eyeTrackingVideoPlayer');
            if (videoPlayer.paused) {
                videoPlayer.play();
            } else {
                videoPlayer.pause();
            }
        }

        // 修改：开始视频实验
        async function startVideoExperiment() {
            if (!isTracking) {
                swal('提示', '请先启动眼动追踪系统！', 'warning');
                return;
            }

            if (!webgazerReady) {
                swal('提示', '请等待眼动追踪系统准备就绪！', 'warning');
                return;
            }

            const videoPlayer = document.getElementById('eyeTrackingVideoPlayer');
            const playBtn = document.getElementById('playVideoBtn');
            
            try {
                // 重置视频到开始位置
                videoPlayer.currentTime = 0;
                
                // 先开始播放视频
                await videoPlayer.play();
                debug('视频开始播放，准备进入放大模式');
                
                // 稍等片刻再进入放大模式
                setTimeout(async () => {
                    try {
                        await enterEnlargedMode(videoPlayer);
                        debug('已成功进入放大模式');
                    } catch (error) {
                        debug(`放大模式失败，继续正常模式: ${error.message}`);
                    }
                }, 100);
                
                // 更新按钮状态
                playBtn.textContent = '🎬 实验进行中...';
                playBtn.disabled = true;
                
                isVideoExperimentActive = true;
                debug('视频实验已开始，开始记录眼动数据');
                
            } catch (error) {
                console.error('启动视频实验失败:', error);
                debug(`启动视频实验失败: ${error.message}`);
                swal('错误', '无法启动视频实验，请检查浏览器权限！', 'error');
            }
        }

        // 新增：人脸检测边框显示功能
        function updateFaceOverlay() {
            if (!webgazer || !webgazer.isReady()) return;
            
            try {
                // 获取WebGazer的人脸检测信息
                const faceDetectionContainer = document.getElementById('faceOverlayContainer');
                
                // 清除旧的覆盖层
                faceDetectionOverlays.forEach(overlay => {
                    if (overlay.parentNode) {
                        overlay.parentNode.removeChild(overlay);
                    }
                });
                faceDetectionOverlays = [];
                
                // 获取WebGazer视频元素
                const webgazerVideo = document.querySelector('#webgazerVideoContainer video');
                if (!webgazerVideo) return;
                
                // 模拟人脸边框（实际应用中需要从WebGazer获取真实的人脸检测数据）
                const videoRect = webgazerVideo.getBoundingClientRect();
                
                // 创建人脸检测边框
                const faceOverlay = document.createElement('div');
                faceOverlay.className = 'face-overlay';
                faceOverlay.style.left = (videoRect.left + videoRect.width * 0.2) + 'px';
                faceOverlay.style.top = (videoRect.top + videoRect.height * 0.15) + 'px';
                faceOverlay.style.width = (videoRect.width * 0.6) + 'px';
                faceOverlay.style.height = (videoRect.height * 0.7) + 'px';
                
                document.body.appendChild(faceOverlay);
                faceDetectionOverlays.push(faceOverlay);
                
            } catch (error) {
                debug(`更新人脸检测边框失败: ${error.message}`);
            }
        }

        // 启动人脸检测边框更新
        function startFaceDetectionOverlay() {
            if (webgazer && webgazer.isReady()) {
                setInterval(updateFaceOverlay, 100); // 每100ms更新一次
                debug('人脸检测边框显示已启动');
            }
        }

        // ===========================================
        // 修改：眼动数据处理 - 适配非全屏模式
        // ===========================================
        function gazeDataCallback(data, elapsedTime) {
            if (isCalibrating || !isTracking) return;
            
            // 数据质量验证
            if (!data || typeof data.x !== 'number' || typeof data.y !== 'number' || 
                isNaN(data.x) || isNaN(data.y) || data.x < 0 || data.y < 0) return;

            const timestamp = new Date().toISOString();
            const videoTimestamp = getAccurateVideoTimestamp();

            let gazePoint = { 
                x: Math.floor(data.x), 
                y: Math.floor(data.y), 
                timestamp, 
                elapsedTime: elapsedTime || Date.now() - startTime, 
                sessionId, 
                userId,
                videoTimestamp: videoTimestamp,
                relativeX: null,
                relativeY: null,
                isVideoActive: isVideoExperimentActive,
                isEnlarged: isVideoEnlarged, // 修改：记录是否为放大模式
                coordinateSystem: isVideoEnlarged ? 'enlarged' : 'normal'
            };

            // 修改：视频相对坐标计算适配放大模式
            if (isVideoExperimentActive && videoTimestamp !== null) {
                const videoPlayer = document.getElementById('eyeTrackingVideoPlayer');
                
                if (isVideoEnlarged) {
                    // 放大模式：计算相对于整个视口的坐标
                    if (videoPlayer.videoWidth > 0 && videoPlayer.videoHeight > 0) {
                        const videoAspect = videoPlayer.videoWidth / videoPlayer.videoHeight;
                        const screenAspect = window.innerWidth / window.innerHeight;
                        
                        let videoDisplayWidth, videoDisplayHeight, videoDisplayX, videoDisplayY;
                        
                        if (videoAspect > screenAspect) {
                            videoDisplayWidth = window.innerWidth;
                            videoDisplayHeight = window.innerWidth / videoAspect;
                            videoDisplayX = 0;
                            videoDisplayY = (window.innerHeight - videoDisplayHeight) / 2;
                        } else {
                            videoDisplayHeight = window.innerHeight;
                            videoDisplayWidth = window.innerHeight * videoAspect;
                            videoDisplayX = (window.innerWidth - videoDisplayWidth) / 2;
                            videoDisplayY = 0;
                        }
                        
                        const relX = gazePoint.x - videoDisplayX;
                        const relY = gazePoint.y - videoDisplayY;
                        
                        if (relX >= 0 && relX <= videoDisplayWidth && relY >= 0 && relY <= videoDisplayHeight) {
                            gazePoint.relativeX = Math.round((relX / videoDisplayWidth) * videoPlayer.videoWidth);
                            gazePoint.relativeY = Math.round((relY / videoDisplayHeight) * videoPlayer.videoHeight);
                        }
                    }
                } else {
                    // 正常模式：计算相对于视频元素的坐标
                    const videoRect = videoPlayer.getBoundingClientRect();
                    const relX = gazePoint.x - videoRect.left;
                    const relY = gazePoint.y - videoRect.top;

                    if (relX >= 0 && relX <= videoRect.width && relY >= 0 && relY <= videoRect.height) {
                        gazePoint.relativeX = Math.round((relX / videoRect.width) * videoPlayer.videoWidth);
                        gazePoint.relativeY = Math.round((relY / videoRect.height) * videoPlayer.videoHeight);
                    }
                }
            }

            // 处理眼动数据
            processSaccadeAndFixation(gazePoint);
            eyeTrackingData.gazePoints.push(gazePoint);
            
            // 添加到热力图累积数据
            allTimeGazePoints.push({
                x: gazePoint.x,
                y: gazePoint.y,
                timestamp: gazePoint.timestamp,
                videoTimestamp: gazePoint.videoTimestamp,
                isVideoActive: gazePoint.isVideoActive,
                isEnlarged: gazePoint.isEnlarged
            });
            
            // 更新热力图显示
            if (heatmapInstance) {
                heatmapInstance.addData({ x: gazePoint.x, y: gazePoint.y, value: 5 });
            }
            
            gazeCount++;
            if (gazeCount % 50 === 0) {
                updateStatsDisplay();
                debug(`已记录 ${gazeCount} 个注视点，热力图累积: ${allTimeGazePoints.length}`);
            }
        }

        // 新增：获取精确视频时间戳
        function getAccurateVideoTimestamp() {
            const videoPlayer = document.getElementById('eyeTrackingVideoPlayer');
            if (!videoPlayer || videoPlayer.paused || !isVideoExperimentActive) {
                return null;
            }
            
            // 使用高精度计时器进行时间同步
            if (videoPlayer._playStartTime && videoPlayer._playStartVideoTime !== undefined) {
                const elapsedRealTime = (performance.now() - videoPlayer._playStartTime) / 1000;
                const calculatedVideoTime = videoPlayer._playStartVideoTime + elapsedRealTime;
                
                // 与实际视频时间进行校验
                const actualVideoTime = videoPlayer.currentTime;
                const timeDiff = Math.abs(calculatedVideoTime - actualVideoTime);
                
                if (timeDiff < 0.1) {
                    return parseFloat(calculatedVideoTime.toFixed(4));
                } else {
                    // 误差较大时使用实际时间并重新校准
                    videoPlayer._playStartTime = performance.now();
                    videoPlayer._playStartVideoTime = actualVideoTime;
                    return parseFloat(actualVideoTime.toFixed(4));
                }
            }
            
            return parseFloat(videoPlayer.currentTime.toFixed(4));
        }

        // 修改：热力图截图功能，添加人脸检测边框
        async function captureHeatmapSnapshot() {
            const heatmapContainer = document.getElementById('heatmapContainer');
            const videoInfoOverlay = document.getElementById('videoInfoOverlay');
            const originalVisibility = heatmapContainer.style.visibility;
            const originalOverlayVisibility = videoInfoOverlay.style.visibility;
            
            try {
                debug(`热力图快照捕获开始 - 放大模式: ${isVideoEnlarged}, 累积点数: ${allTimeGazePoints.length}`);
                
                const originalVideo = document.getElementById('eyeTrackingVideoPlayer');
                const currentVideoTime = originalVideo.currentTime || 0;
                
                // 创建截图Canvas
                const screenshotCanvas = document.createElement('canvas');
                const screenshotCtx = screenshotCanvas.getContext('2d');
                
                if (isVideoEnlarged) {
                    screenshotCanvas.width = window.innerWidth;
                    screenshotCanvas.height = window.innerHeight;
                } else {
                    screenshotCanvas.width = Math.max(1920, window.innerWidth);
                    screenshotCanvas.height = Math.max(1080, window.innerHeight);
                }
                
                debug(`截图Canvas尺寸: ${screenshotCanvas.width}x${screenshotCanvas.height}`);
                
                // 1. 绘制背景
                screenshotCtx.fillStyle = isVideoEnlarged ? '#000000' : '#f0f0f0';
                screenshotCtx.fillRect(0, 0, screenshotCanvas.width, screenshotCanvas.height);
                
                // 2. 绘制视频内容
                if (originalVideo && !originalVideo.paused && originalVideo.videoWidth > 0 && originalVideo.videoHeight > 0) {
                    const videoAspect = originalVideo.videoWidth / originalVideo.videoHeight;
                    const screenAspect = screenshotCanvas.width / screenshotCanvas.height;
                    
                    let drawWidth, drawHeight, drawX, drawY;
                    
                    if (videoAspect > screenAspect) {
                        drawWidth = screenshotCanvas.width;
                        drawHeight = screenshotCanvas.width / videoAspect;
                        drawX = 0;
                        drawY = (screenshotCanvas.height - drawHeight) / 2;
                    } else {
                        drawHeight = screenshotCanvas.height;
                        drawWidth = screenshotCanvas.height * videoAspect;
                        drawX = (screenshotCanvas.width - drawWidth) / 2;
                        drawY = 0;
                    }
                    
                    // 绘制视频帧
                    screenshotCtx.drawImage(originalVideo, drawX, drawY, drawWidth, drawHeight);
                    
                    // 新增：绘制人脸检测边框
                    screenshotCtx.strokeStyle = '#00ff00';
                    screenshotCtx.lineWidth = 3;
                    screenshotCtx.fillStyle = 'rgba(0, 255, 0, 0.1)';
                    
                    // 假设人脸在视频中央区域（实际应用中应该从WebGazer获取真实位置）
                    const faceX = drawX + drawWidth * 0.25;
                    const faceY = drawY + drawHeight * 0.2;
                    const faceWidth = drawWidth * 0.5;
                    const faceHeight = drawHeight * 0.6;
                    
                    screenshotCtx.fillRect(faceX, faceY, faceWidth, faceHeight);
                    screenshotCtx.strokeRect(faceX, faceY, faceWidth, faceHeight);
                    
                    // 添加人脸检测标签
                    screenshotCtx.fillStyle = '#00ff00';
                    screenshotCtx.font = 'bold 16px Arial';
                    screenshotCtx.fillText('Face Detected', faceX, faceY - 5);
                }
                
                // 3. 重建热力图数据
                if (allTimeGazePoints.length > 0) {
                    const tempHeatmapContainer = document.createElement('div');
                    tempHeatmapContainer.style.position = 'absolute';
                    tempHeatmapContainer.style.top = '0';
                    tempHeatmapContainer.style.left = '0';
                    tempHeatmapContainer.style.width = screenshotCanvas.width + 'px';
                    tempHeatmapContainer.style.height = screenshotCanvas.height + 'px';
                    tempHeatmapContainer.style.pointerEvents = 'none';
                    document.body.appendChild(tempHeatmapContainer);
                    
                    const tempHeatmapInstance = h337.create({
                        container: tempHeatmapContainer,
                        radius: Math.max(25, screenshotCanvas.width / 60),
                        maxOpacity: 0.8,
                        minOpacity: 0.1,
                        blur: 0.8
                    });
                    
                    const heatmapDataPoints = allTimeGazePoints.map(point => ({
                        x: point.x,
                        y: point.y,
                        value: 5
                    }));
                    
                    tempHeatmapInstance.setData({
                        data: heatmapDataPoints,
                        max: 10
                    });
                    
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    const tempHeatmapCanvas = tempHeatmapContainer.querySelector('canvas');
                    if (tempHeatmapCanvas && tempHeatmapCanvas.width > 0 && tempHeatmapCanvas.height > 0) {
                        screenshotCtx.globalAlpha = 0.7;
                        screenshotCtx.drawImage(tempHeatmapCanvas, 0, 0, screenshotCanvas.width, screenshotCanvas.height);
                        screenshotCtx.globalAlpha = 1.0;
                    }
                    
                    document.body.removeChild(tempHeatmapContainer);
                }
                
                // 4. 添加WebGazer视频预览框
                const webgazerVideo = document.querySelector('#webgazerVideoContainer video');
                if (webgazerVideo && webgazerVideo.videoWidth > 0) {
                    const previewX = 20;
                    const previewY = 80;
                    const previewWidth = 320;
                    const previewHeight = 240;
                    
                    // 绘制WebGazer视频预览
                    screenshotCtx.drawImage(webgazerVideo, previewX, previewY, previewWidth, previewHeight);
                    
                    // 绘制预览框边框
                    screenshotCtx.strokeStyle = '#4CAF50';
                    screenshotCtx.lineWidth = 3;
                    screenshotCtx.strokeRect(previewX, previewY, previewWidth, previewHeight);
                    
                    // 添加标签
                    screenshotCtx.fillStyle = '#4CAF50';
                    screenshotCtx.font = 'bold 14px Arial';
                    screenshotCtx.fillText('WebGazer Preview', previewX, previewY - 5);
                }
                
                // 5. 添加信息覆盖层
                screenshotCtx.font = 'bold 20px Arial';
                screenshotCtx.fillStyle = 'rgba(255, 0, 0, 0.9)';
                const overlayText = `用户: ${userId} | 时间: ${currentVideoTime.toFixed(2)}s | 点数: ${allTimeGazePoints.length} | 模式: ${isVideoEnlarged ? '放大' : '正常'}`;
                const overlayMetrics = screenshotCtx.measureText(overlayText);
                screenshotCtx.fillRect(10, 10, overlayMetrics.width + 20, 35);
                screenshotCtx.fillStyle = 'rgba(255, 255, 255, 1)';
                screenshotCtx.fillText(overlayText, 20, 32);
                
                // 6. 上传到Cloudinary
                const imageDataUrl = screenshotCanvas.toDataURL('image/png', 0.95);
                const cloudName = 'ddp3tohxk';
                const uploadPreset = 'index1';
                const url = `https://api.cloudinary.com/v1_1/${cloudName}/image/upload`;
                
                const heatmapFileName = `${userId}_${currentVideoTime.toFixed(2)}s_热力图_${allTimeGazePoints.length}点_${isVideoEnlarged ? '放大' : '正常'}模式`;
                
                const formData = new FormData();
                formData.append('file', imageDataUrl);
                formData.append('upload_preset', uploadPreset);
                formData.append('folder', `视频热力图/${userId}/${sessionId}`);
                formData.append('public_id', heatmapFileName);
                
                const response = await fetch(url, { method: 'POST', body: formData });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Cloudinary上传失败: ${errorData.error.message}`);
                }
                const data = await response.json();
                const secureUrl = data.secure_url;
                debug(`热力图上传成功: ${secureUrl}`);
                
                eyeTrackingData.heatmapSnapshots.push({ 
                    timestamp: new Date().toISOString(), 
                    storageUrl: secureUrl, 
                    provider: 'cloudinary', 
                    sessionId, 
                    userId,
                    videoTimestamp: currentVideoTime,
                    method: 'enhanced_with_face_detection',
                    fileName: heatmapFileName,
                    imageSize: `${screenshotCanvas.width}x${screenshotCanvas.height}`,
                    isEnlarged: isVideoEnlarged,
                    captureType: 'heatmap_with_face_overlay',
                    totalDataPoints: allTimeGazePoints.length,
                    features: ['face_detection', 'webgazer_preview', 'enhanced_overlay']
                });
                heatmapSnapshotCount++;
                updateStatsDisplay();
                
            } catch (error) {
                console.error("捕获热力图快照时出错: ", error);
                debug(`捕获热力图快照时出错: ${error.message}`);
            } finally {
                heatmapContainer.style.visibility = originalVisibility;
                videoInfoOverlay.style.visibility = originalOverlayVisibility;
            }
        }

        function startAutoSave() {
            if (autoSaveInterval) clearInterval(autoSaveInterval);
            autoSaveInterval = setInterval(() => saveEyeTrackingData(false), 5000); // 改为5秒保存一次，便于调试
            updateCollectionStatus('进行中 (自动)', 'connected');
        }

        function stopAutoSave() { if (autoSaveInterval) clearInterval(autoSaveInterval); }

        async function saveEyeTrackingData(isManual = false) {
            if (!firebaseConnected) { 
                if(isManual) swal('错误', 'Firebase未连接，无法保存。', 'error'); 
                return; 
            }
            
            const totalPoints = eyeTrackingData.gazePoints.length + eyeTrackingData.saccades.length + eyeTrackingData.fixations.length;
            debug(`准备保存数据 - 注视点: ${eyeTrackingData.gazePoints.length}, 眼跳: ${eyeTrackingData.saccades.length}, 注视: ${eyeTrackingData.fixations.length}, 总计: ${totalPoints}, 热力图累积: ${allTimeGazePoints.length}`);
            
            if (totalPoints === 0) { 
                debug('没有新数据可保存');
                if(isManual) swal('提示', '没有新数据可保存。', 'info'); 
                return; 
            }

            const dataToSave = JSON.parse(JSON.stringify(eyeTrackingData));
            
            const payload = { 
                sessionId, 
                userId, 
                timestamp: new Date().toISOString(), 
                dataType: isManual ? 'manual' : 'auto',
                experimentType: 'video_eye_tracking',
                videoInfo: {
                    videoUrl: document.getElementById('eyeTrackingVideoPlayer').src,
                    videoDuration: document.getElementById('eyeTrackingVideoPlayer').duration || null
                },
                gazeData: dataToSave.gazePoints,
                saccadeData: dataToSave.saccades, 
                fixationData: dataToSave.fixations,
                calibrationInfo: dataToSave.calibrationData,
                statistics: {
                    totalGazePoints: dataToSave.gazePoints.length,
                    totalSaccades: dataToSave.saccades.length,
                    totalFixations: dataToSave.fixations.length,
                    cumulativeHeatmapPoints: allTimeGazePoints.length, // 新增：累积热力图点数
                    averageFixationDuration: dataToSave.fixations.length > 0 ? 
                        Math.round(dataToSave.fixations.reduce((sum, f) => sum + f.duration, 0) / dataToSave.fixations.length) : 0,
                    sessionDuration: Date.now() - startTime
                }
            };
            
            debug(`准备上传Firebase payload，累积热力图点数: ${allTimeGazePoints.length}`);
            
            // 修改：清空保存数据，但保留热力图累积数据
            eyeTrackingData.gazePoints = []; 
            eyeTrackingData.saccades = []; 
            eyeTrackingData.fixations = [];
            // 注意：不清空 allTimeGazePoints，保持热力图数据累积
            
            updateCollectionStatus('保存中...', 'uploading');
            try {
                const docRef = await db.collection("eye_tracking_video_experiment_v1").add(payload);
                snapshotCount++;
                updateCollectionStatus('进行中 (自动)', 'connected');
                debug(`数据快照 #${snapshotCount} 保存成功，累积热力图点数: ${allTimeGazePoints.length}`);
                if(isManual) swal('成功', `数据已保存！\n累积热力图点数: ${allTimeGazePoints.length}\n文档ID: ${docRef.id}`, 'success');
            } catch (error) {
                console.error("Firebase 保存失败: ", error);
                debug(`数据保存失败: ${error.message}, 正在恢复数据...`);
                updateCollectionStatus('保存失败', 'disconnected');
                if(isManual) swal('失败', `数据保存失败！\n\n${error.message}`, 'error');
                eyeTrackingData.gazePoints = dataToSave.gazePoints.concat(eyeTrackingData.gazePoints);
                eyeTrackingData.saccades = dataToSave.saccades.concat(eyeTrackingData.saccades);
                eyeTrackingData.fixations = dataToSave.fixations.concat(eyeTrackingData.fixations);
            }
        }

        // =======================================================================
        // 官方校准与百分比精度测试流程
        // =======================================================================
        
        function ClearCanvas(){
            document.querySelectorAll('.Calibration').forEach((i) => { i.style.display = 'none'; });
            var canvas = document.getElementById("plotting_canvas");
            canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
        }
        
        function PopUpInstruction() {
            if (!isTracking) return swal('提示', '请先启动眼动追踪。', 'info');
            
            // 设置校准状态标志
            isCalibrating = true;
            
            document.getElementById('statsPanel').style.display = 'none';
            // 隐藏控制按钮避免遮挡校准点
            document.querySelector('.controls').style.display = 'none';
            ClearCanvas();
            swal({
                title:"校准说明",
                text: "请点击屏幕上出现的9个点。您必须在每个点上点击5次，直到它变成黄色。这将校准您的眼动追踪。",
                buttons:{ cancel: false, confirm: "开始" }
            }).then(() => {
                updateStatus('校准进行中', 'calibrating');
                debug('开始9点校准流程');
                ShowCalibrationPoint();
                document.querySelectorAll('.Calibration').forEach((i) => { i.onclick = () => calPointClick(i); });
            });
        }
        
        function ShowCalibrationPoint() {
            document.querySelectorAll('.Calibration').forEach((i) => { i.style.display = 'block'; });
            document.getElementById('Pt5').style.display = 'none';
        }
        
        function calPointClick(node) {
            const id = node.id;
            if (!CalibrationPoints[id]) CalibrationPoints[id] = 0;
            CalibrationPoints[id]++; 
            node.style.opacity = 0.2 * CalibrationPoints[id] + 0.2;
            if (CalibrationPoints[id] == 5) {
                node.style.backgroundColor = 'yellow';
                node.setAttribute('disabled', 'disabled');
                PointCalibrate++;
                debug(`校准点 ${id} 完成，当前完成数量: ${PointCalibrate}`);
                
                // 前8个点点击完后，显示Pt5
                if (PointCalibrate === 8) {
                    document.getElementById('Pt5').style.display = 'block';
                    debug('显示第9个校准点 Pt5');
                }
                // 只有Pt5点击完才进入精度计算
                if (PointCalibrate === 9) {
                    debug('所有校准点完成，开始精度计算');
                    document.querySelectorAll('.Calibration').forEach((i) => { if(i.id !== 'Pt5') i.style.display = 'none'; });
                    calcAccuracy();
                }
            }
        }

        function calcAccuracy() {
            swal({
                title: "正在计算精度",
                text: "请不要移动您的鼠标，并尽力注视屏幕中央的点5秒钟。这将帮助我们计算预测的准确性。",
                closeOnEsc: false, allowOutsideClick: false, closeModal: true
            }).then(() => {
                updateStatus('精度测试中...', 'calibrating');
                if (webgazer) webgazer.params.storingPoints = true;
                sleep(5000).then(() => {
                    if (webgazer) webgazer.params.storingPoints = false;
                    var past50 = webgazer.getStoredPoints();
                    var precisionPercentage = calculatePrecision(past50);
                    
                    document.getElementById('Accuracy').innerHTML = `测试精度: ${precisionPercentage}%`;
                    eyeTrackingData.calibrationData = {
                        points: CalibrationPoints,
                        accuracyPercentage: precisionPercentage,
                        timestamp: new Date().toISOString()
                    };
                    
                    swal({
                        title: `您的追踪精度为 ${precisionPercentage}%`,
                        allowOutsideClick: false,
                        buttons: { cancel: "重新校准", confirm: "接受" }
                    }).then(isConfirm => {
                        document.getElementById('statsPanel').style.display = 'block';
                        // 恢复显示控制按钮
                        document.querySelector('.controls').style.display = 'block';
                        if (isConfirm) {
                            ClearCanvas();
                            updateStatus('运行中', 'ready');
                            // 校准完成，重置校准状态
                            isCalibrating = false;
                        } else {
                            document.getElementById("Accuracy").innerHTML = "等待校准...";
                            webgazer.clearData();
                            Restart();
                        }
                    });
                });
            });
        }
        
        function sleep(time) { return new Promise((resolve) => setTimeout(resolve, time)); }
        
        function calculatePrecision(past50Array) {
          var windowHeight = window.innerHeight;
          var staringPointX = window.innerWidth / 2;
          var staringPointY = windowHeight / 2;
          var x50 = past50Array[0];
          var y50 = past50Array[1];
          var precisionPercentages = new Array(50);
          for (let x = 0; x < 50; x++) {
            var xDiff = staringPointX - x50[x];
            var yDiff = staringPointY - y50[x];
            var distance = Math.sqrt((xDiff * xDiff) + (yDiff * yDiff));
            var halfWindowHeight = windowHeight / 2;
            var precision = 100 - (distance / halfWindowHeight * 100);
            precisionPercentages[x] = Math.max(0, precision);
          }
          return Math.round(precisionPercentages.reduce((a, b) => a + b, 0) / 50);
        };

        function Restart() {
            if (!webgazerReady) return;
            document.getElementById('Accuracy').innerHTML = "等待校准...";
            if(webgazer) webgazer.clearData();
            ClearCalibration();
            ClearCanvas();
            updateStatus('准备重新校准', 'ready');
            // 确保重新校准时也隐藏控制按钮
            document.querySelector('.controls').style.display = 'none';
            PopUpInstruction();
        }

        function ClearCalibration() {
            document.querySelectorAll('.Calibration').forEach((i) => {
                i.style.backgroundColor = 'red';
                i.style.opacity = '0.2';
                i.removeAttribute('disabled');
            });
            CalibrationPoints = {};
            PointCalibrate = 0;
        }

        // =======================================================================
        // 系统控制与生命周期
        // =======================================================================

        function toggleDebug() { debugMode = !debugMode; document.getElementById('debugPanel').style.display = debugMode ? 'block' : 'none'; }
        
        function toggleHeatmap() { 
            const heatmapContainer = document.getElementById('heatmapContainer');
            heatmapContainer.classList.toggle('heatmap-visible');
            heatmapContainer.style.visibility = heatmapContainer.classList.contains('heatmap-visible') ? 'visible' : 'hidden';
        }
        
        function startStatsUpdate() {
            if (statsUpdateInterval) clearInterval(statsUpdateInterval);
            statsUpdateInterval = setInterval(() => { if (isTracking) { document.getElementById('runningTime').textContent = Math.round((Date.now() - startTime) / 1000) + 's'; updateStatsDisplay(); } }, 1000);
        }
        function stopStatsUpdate() { if (statsUpdateInterval) clearInterval(statsUpdateInterval); }
        
        function exportData() {
            if (gazeCount === 0) return swal('无数据', '沒有可导出的数据。', 'warning');
            const dataStr = JSON.stringify({ sessionInfo: { sessionId, userId }, collectedData: eyeTrackingData }, null, 2);
            const link = document.createElement('a');
            link.href = URL.createObjectURL(new Blob([dataStr], {type: 'application/json'}));
            link.download = `eye-tracking-data-${sessionId}.json`;
            link.click();
            URL.revokeObjectURL(link.href);
        }

        async function initializeSystem() {
            try {
                if (typeof h337 === 'undefined' || typeof swal === 'undefined') throw new Error('依赖库加载失败');
                if (!await loadWebGazerScript() || typeof webgazer === 'undefined') throw new Error('WebGazer加载失败');
                heatmapInstance = h337.create({ container: document.getElementById('heatmapContainer'), radius: 25, maxOpacity: 0.6, minOpacity: 0.1, blur: 0.8 });
                await testFirebaseConnection();
                updateStatus('系统就绪', 'ready');
                document.getElementById('startBtn').disabled = false;
                librariesLoaded = true;
                ClearCanvas();
                setupVideoPlayer();
            } catch (error) {
                updateStatus('初始化失败', 'error');
                swal('严重错误', `系统初始化失败:\n\n${error.message}`, 'error');
            }
        }

        async function startEyeTracking() {
            if (!librariesLoaded) return;
            const startBtn = document.getElementById('startBtn');
            startBtn.disabled = true;
            updateStatus('初始化WebGazer...', 'initializing');
            try {
                await webgazer.setRegression('ridge').setTracker('clmtrackr').setGazeListener(gazeDataCallback).begin();
                webgazer.showVideoPreview(true).showPredictionPoints(true).applyKalmanFilter(true);
                isTracking = true; startTime = Date.now(); webgazerReady = true;
                
                // 新增：启动人脸检测边框显示
                startFaceDetectionOverlay();
                
                if (firebaseConnected) startAutoSave();
                startHeatmapSnapshots(); startStatsUpdate();
                updateStatus('运行中', 'ready');
                document.getElementById('calibrateBtn').disabled = false;
                startBtn.textContent = '✅ 运行中';
                swal('启动成功', '眼动追踪已启动！\n强烈建议您点击"开始校准"以提高精度。', 'success');
            } catch (error) {
                console.error("启动眼动追踪失败:", error);
                updateStatus('启动失败', 'error');
                startBtn.disabled = false;
                swal('启动失败', `无法启动眼动追踪。\n请检查摄像头权限。\n\n${error.message}`, 'error');
            }
        }

        window.addEventListener('load', initializeSystem);
        window.addEventListener('error', (e) => debug(`全局错误: ${e.message}`));
        window.addEventListener('unhandledrejection', (e) => debug(`Promise拒绝: ${e.reason}`));
        window.addEventListener('beforeunload', (e) => {
            if (isTracking && eyeTrackingData.gazePoints.length > 0) {
                const message = '您有未保存的数据，确定要离开吗？';
                e.returnValue = message; return message;
            }
        });
        document.addEventListener('visibilitychange', () => {
            if (isTracking && webgazer) {
                document.visibilityState === 'hidden' ? webgazer.pause() : webgazer.resume();
            }
        });
    </script>
</body>
</html>
